---
title: 流量复制技术-tcpcopy
date: 2023-08-07 21:46:40
permalink: /pages/154209/
categories:
  - 后端技术
  - Linux
tags:
  - 
author: 
  name: erlangtui
  link: https://github.com/zhangliang6666
---

> TCPCopy 是一个 TCP 流重放工具，支持互联网服务器应用程序的实际测试
<!-- more -->
## 一、简介
* 背景：线上流量过于复杂，难以模拟出真实的请求对线上服务进行测试；
* TCPCopy 作为一个实时流重放工具，能够生成类似于生产环境的流量；
* TCPCopy 是**对 tcp 包进行转发，与应用层协议无关**，mysql、redis、protobuf等都可以转发；
* TCPCopy 除了**占用额外的 CPU、内存和带宽外**，对生产系统几乎没有影响；
* 复制工作负载在请求多样性、网络延迟和资源占用方面与生产工作负载相似。

## 二、应用场景
* 分布式压力测试：
  * 使用 TCPCopy 复制真实数据，对服务器软件进行压力测试，可以找到只能在高压力情况下产生的错误；
* 稳定性测试：
  * 证明新系统是稳定的，并找到只发生在生产环境中的错误；
* 回归测试：
  * 利用 TCPCopy 复制生产流量，复现bug问题；
* 性能比较
  * 利用 TCPCopy 复制或放大生产流量，验证新版本性能是否达标；

## 三、架构设计
![架构图](/img/tcpcopy.png)

* TCPCOPY 默认使用**原始套接字输入技术**在**网络层**捕获在线数据包并进行必要的处理（包括TCP交互模拟、网络延迟控制和常见的上层交互模拟），并默认使用**原始套接字输出技术**将数据包发送到目标服务器（图中用粉红色箭头表示）；
* TCPCopy 由两部分组成：tcpcopy 和 intercept；
  * tcpcopy 运行在线上服务器，对真实请求的 tcp 包进行复制并转发到目标服务器上；
  * intercept 运行在助理服务器上，执行一些辅助工作，例如将目标服务器的响应信息传递给 tcpcopy；
* 目标服务器上唯一需要的操作是设置适当的路由命令，以将响应数据包（图中的绿色箭头所示）路由到助理服务器；
* intercept 将提取响应标头信息，并使用特殊通道将响应标头发送到 tcpcopy（图中紫色箭头所示）；
* tcpcopy 收到响应标头时，它会利用标头信息修改联机数据包的属性，并继续发送另一个数据包；
* 应该注意的是，来自目标服务器的响应被路由到助理服务器，该服务器应该充当**黑洞**；

## 四、快速入门
### 1，线上机器上安装 tcpcopy
```bash
 wget https://github.com/session-replay-tools/tcpcopy/archive/1.0.0.tar.gz
 tar -zxf 1.0.0.tar.gz
 cd tcpcopy-1.0.0
 ./configure --prefix=/opt/tcpcopy/ # 默认安装目录 /usr/local/tcpcopy
 make
 make install
```
### 2，助理机器上安装 intercept
```bash
 yum -y install libpcap-devel # 在Unix-like系统上捕获网络数据包的库
 wget https://github.com/session-replay-tools/intercept/archive/1.0.0.tar.gz
 tar -zxf 1.0.0.tar.gz
 cd intercept-1.0.0
 ./configure --prefix=/opt/tcpcopy/ # 和上面目录一致
 make
 make install
```
<!-- 
配置拦截选项
--single            run intercept at non-distributed mode
--with-pfring=PATH  set path to PF_RING library sources
--with-debug        compile intercept with debug support (saved in a log file)

配置 tcpcopy 的选项
--offline                   replay TCP streams from the pcap file
--pcap-capture              capture packets at the data link
--pcap-send                 send packets at the data link layer instead of the IP layer
--with-pfring=PATH          set path to PF_RING library sources
--set-protocol-module=PATH  set tcpcopy to work for an external protocol module
--single                    if intercept and tcpcopy are both configured with "--single" option, 
                            only one tcpcopy works together with intercept, 
                            and better performance is achieved.
--with-tcmalloc             use tcmalloc instead of malloc
--with-debug                compile tcpcopy with debug support (saved in a log file)
运行 TCPCopy
假设 tcpcopy 和 intercept 都配置了“./configure”。

1） 在运行服务器应用程序的目标服务器上：
  Set route commands appropriately to route response packets to the assistant server

  For example:

     Assume 61.135.233.161 is the IP address of the assistant server. We set the 
     following route command to route all responses to the 62.135.200.x's clients 
     to the assistant server.

       route add -net 62.135.200.0 netmask 255.255.255.0 gw 61.135.233.161
2） 在运行拦截的助手服务器上（需要 root 权限或CAP_NET_RAW功能）：
   ./intercept -F <filter> -i <device,>
   
   Note that the filter format is the same as the pcap filter.
   For example:
   
      ./intercept -i eth0 -F 'tcp and src port 8080' -d
      
      intercept will capture response packets of the TCP based application which listens
      on port 8080 from device eth0 
3） 在联机源服务器上（需要 root 权限或CAP_NET_RAW功能）：
  ./tcpcopy -x localServerPort-targetServerIP:targetServerPort -s <intercept server,> 
  [-c <ip range,>]
  
  For example(assume 61.135.233.160 is the IP address of the target server):

    ./tcpcopy -x 80-61.135.233.160:8080 -s 61.135.233.161 -c 62.135.200.x
    
    tcpcopy would capture port '80' packets on current server, change client IP address 
    to one of 62.135.200.x series, send these packets to the target port '8080' of the 
    target server '61.135.233.160', and connect 61.135.233.161 for asking intercept to 
    pass response packets to it.
    
    Although "-c" parameter is optional, it is set here in order to simplify route 
    commands.
注意
它仅在Linux上进行测试（内核2.6或更高版本）
TCPCopy 可能会丢失数据包，从而丢失请求
需要根权限或CAP_NET_RAW功能（例如setcap CAP_NET_RAW=ep tcpcopy）
TCPCopy 现在仅支持客户端启动的连接
TCPCopy 不支持使用 SSL/TLS 的服务器应用程序的重放
有关 MySQL 会话重播，请参阅 https://github.com/session-replay-tools
不应在助理服务器上设置ip_forward
请执行 “./tcpcopy -h” 或 “./intercept -h” 以获取更多详细信息。
影响因素
有几个因素可能会影响TCPCopy，这将在以下各节中详细介绍。

1. 捕获界面
默认情况下，TCPcopy 利用原始套接字输入接口在联机服务器上的网络层捕获数据包。系统繁忙时，系统内核可能会丢失一些数据包。

如果使用“--pcap-capture”配置 tcpcopy，则 tcpcopy 可以在数据链路层捕获数据包，也可以过滤内核中的数据包。使用 PF_RING，tcpcopy 在使用 pcap 捕获时会丢失更少的数据包。

也许捕获请求的最佳方法是通过交换机镜像入口数据包，然后通过负载均衡器将巨大的流量划分到多台计算机。

2. 发送接口
默认情况下，TCPcopy 利用原始套接字输出接口将网络层的数据包发送到目标服务器。 如果要避免ip_conntrack问题或获得更好的性能，请使用“--pcap-send”配置 tcpcopy，然后使用适当的参数，tcpcopy 可以在数据链路层将数据包发送到目标服务器。

3.在前往目标服务器的途中
当数据包通过 tcpcopy 发送时，在到达目标服务器之前可能会遇到许多挑战。由于数据包中的源IP地址仍然是最终用户的IP地址（默认情况下），而不是在线服务器的IP地址，因此某些安全设备可能会将其视为无效或伪造的数据包并将其丢弃。在这种情况下，当您使用 tcpdump 捕获目标服务器上的数据包时，不会捕获来自预期最终用户的数据包。要了解您是否处于这种情况，您可以选择同一网段中的目标服务器进行测试。如果数据包可以在同一网段中成功发送到目标服务器，但跨网段未成功发送，则数据包可能会中途丢弃。

为了解决这个问题，我们建议在同一网段的服务器上部署tcpcopy，目标应用程序和拦截。在同一网段中的代理的帮助下，还有另一种解决方案。TCPcopy 可以将数据包发送到代理，然后代理会将相应的请求发送到另一个网段中的目标服务器。

请注意，在同一段中的一个虚拟机上部署目标服务器的应用程序可能会面临上述问题。

4. 目标服务器的操作系统
目标服务器可以设置 rpfilter，这将检查数据包中的源 IP 地址是否是伪造的。如果是，数据包将在网络层丢弃。

如果目标服务器无法接收任何请求，尽管目标服务器上的 tcpdump 可以捕获数据包，则应检查是否有任何相应的 rpfilter 设置。如果设置，则必须删除相关设置，以使数据包通过网络层。

还有其他原因导致 tcpcopy 无法正常工作，例如 iptables 设置问题。

5. 目标服务器上的应用程序
目标服务器上的应用程序可能无法及时处理所有请求。一方面，应用程序中的错误可能会使请求长时间没有响应。另一方面，TCP 层以上的某些协议可能只处理套接字缓冲区中的第一个请求，而将套接字缓冲区中的剩余请求保留为未处理。

6. 助理服务器的操作系统
您不应ip_forward设置为 true，否则助理服务器无法充当黑洞。

-x <transfer,> use <transfer,> to specify the IPs and ports of the source and target
               servers. Suppose 'sourceIP' and 'sourcePort' are the IP and port
               number of the source server you want to copy from, 'targetIP' and
               'targetPort' are the IP and port number of the target server you want
               to send requests to, the format of <transfer,> could be as follows:
               'sourceIP:sourcePort-targetIP:targetPort,...'. Most of the time,
               sourceIP could be omitted and thus <transfer,> could also be:
               'sourcePort-targetIP:targetPort,...'. As seen, the IP address and the
               port number are segmented by ':' (colon), the sourcePort and the
               targetIP are segmented by '-', and two 'transfer's are segmented by
               ',' (comma). For example, './tcpcopy -x 80-192.168.0.2:18080' would
               copy requests from port '80' on current server to the target port
               '18080' of the target IP '192.168.0.2'.
-H <ip_addr>   change the localhost IP address to the given IP address
-c <ip_addr,>  change the client IP to one of IP addresses when sending to the
               target server. For example,
               './tcpcopy -x 8080-192.168.0.2:8080 -c 62.135.200.x' would copy
               requests from port '8080' of current online server to the target port
               '8080' of target server '192.168.0.2' and modify the client IP to be
               one of net 62.135.200.0/24.
-n <num>       use <num> to set the replication times when you want to get a
               copied data stream that is several times as large as the online data.
               The maximum value allowed is 1023. As multiple copying is based on
               port number modification, the ports may conflict with each other,
               in particular in intranet applications where there are few source IPs
               and most connections are short. Thus, tcpcopy would perform better
               when less copies are specified. For example,
               './tcpcopy -x 80-192.168.0.2:8080 -n 3' would copy data flows from
               port 80 on the current server, generate data stream that is three
               times as large as the source data, and send these requests to the
               target port 8080 on '192.168.0.2'.
-f <num>       use this parameter to control the port number modification process
               and reduce port conflications when multiple tcpcopy instances are
               running. The value of <num> should be different for different tcpcopy
               instances. The maximum value allowed is 1023.
-m <num>       set the maximum memory allowed to use for tcpcopy in megabytes,
               to prevent tcpcopy occupying too much memory and influencing the
               online system. When the memory exceeds this limit, tcpcopy would quit
               automatically. The parameter is effective only when the kernel
               version is 2.6.32 or above. The default value is 1024.
-M <num>       MTU value sent to backend (default 1500)
-D <num>       MSS value sent back(default 1460)
-R <num>       set default rtt value
-U <num>       set user session pool size in kilobytes(default 1).
               The maximum value allowed is 63.
-C <num>       | parallel connections between tcpcopy and intercept.
               The maximum value allowed is 11(default 2 connections).
-s <server,>   intercept 服务列表，形如：ip_addr1:port1, ip_addr2:port2, ...
-t <num>       |  设置会话的超时时间。在超时时间后 tcpcopy 还没收到目标服务器的返回，该会话将被丢弃。当来自目标服务器的响应较慢或应用程序协议基于上下文时，应该设置更大的值。默认值 120 seconds.
-k <num>       |  设置会话保持的超时时间
-l <file>      |  设置日志文件
-r <num>       |  设置会话传输百分比 (integer range:1~100)
-p <num>       |  设置目标服务器的监听端口，默认值 36524.
-P <file>      |  设置 pid 存储的文件，仅用于 -d 选项下
-O             |  仅回放全会话
-g             |  慢慢回放 gradully
-v             |  版本
-h             |  打印帮助并退出
-d             |  以守护进程的方式运行


 -->

选项|含义
----|----
 -i <device,>  |  要侦听的接口的名称，通常是驱动程序名称后面跟着一个单元号，例如，第一个以太网接口为eth0
-F <filter>    |  过滤规则(和 pcap 规则一样)
-n <num>       |  设置最大合并包的数量
-p <num>       |  设置监听的 TCP 端口号，默认 36524
-s <num>       |  为 intercept 设置哈希表的尺寸，默认 65536
-l <file>      |  设置日志文件
-P <file>      |  设置 pid 存储的文件，仅用于 -d 选项下
-b <ip_addr>   |  监听接口 (默认 INADDR_ANY, 所有地址)
-v             |  版本
-h             |  打印帮助并退出
-d             |  以守护进程的方式运行