---
title: redis 内存淘汰策略
date: 2024-02-01 16:14:03
permalink: /pages/c6674a/
categories:
  - 后端技术
  - redis
tags:
  - 
author: 
  name: erlangtui
  link: https://github.com/erlangtui
---

redis 的内存淘汰策略是指在 redis 用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据；

* noeviction：当内存不足时，新写入操作会报错；
* allkeys-lru：当内存不足时，在所有的 key 中移除最近最少使用的 key；
* allkeys-lfu：当内存不足时，在所有的 key 中移除最不常用的 key；
* allkeys-random：当内存不足时，在所有的 key 中随机移除某个key；
* volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
* volatile-lfu：删除最不常用的键，字段设置为 。expiretrue
* volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
* volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。


如果没有与先决条件匹配的逐出键，则策略 volatile-lru、volatile-lfu、volatile-random 和 volatile-ttl 的行为类似于 noeviction。

根据访问模式，选择正确的逐出策略非常重要 但是，您可以在运行时重新配置策略，同时 应用程序正在运行，并监视缓存未命中和命中的次数 使用 redis INFO 输出来调整您的设置。

一般来说，根据经验：

当您期望在请求的受欢迎程度中出现幂律分布时，请使用 allkeys-lru 策略。也就是说，您期望访问元素的子集的频率远远高于其他元素。 如果您不确定，这是一个不错的选择。

如果您具有连续扫描所有密钥的循环访问，或者当您希望分布均匀时，请使用 allkeys-random。

如果您希望在创建缓存对象时能够使用不同的 TTL 值向 redis 提供有关哪些是过期的良好候选项的提示，请使用 volatile-ttl。

volatile-lru 和 volatile-random 策略主要在您希望将单个实例用于缓存和拥有一组持久键时非常有用。但是，运行两个 redis 实例来解决此类问题通常是一个更好的主意。

还值得注意的是，为密钥设置值会消耗内存，因此使用像 allkeys-lru 这样的策略可以提高内存效率，因为不需要在内存压力下逐出密钥的配置。expireexpire

### 逐出过程的运作方式
重要的是要了解驱逐过程的工作方式如下：

客户端运行一个新命令，从而添加更多数据。
redis 会检查内存使用情况，如果内存使用量大于限制，则会根据策略逐出密钥。maxmemory
执行新命令，依此类推。
因此，我们不断越过内存限制的边界，越过它，然后逐出键以返回到限制之下。

如果某个命令导致在一段时间内使用大量内存（例如存储到新键中的大集合交集），则内存限制可能会明显超过。

### 近似 LRU 算法
redis LRU 算法不是一个精确的实现。这意味着 redis 是 无法选择驱逐的最佳人选，即关键 是过去访问最远的。相反，它将尝试运行一个近似值 的 LRU 算法，通过对少量密钥进行采样，然后逐出 一个是采样密钥中最好的（具有最早的访问时间）。

然而，从 redis 3.0 开始，该算法得到了改进，也采用了一个好的池子 驱逐候选人。这提高了算法的性能，使 它能够更接近真实 LRU 算法的行为。

redis LRU 算法的重要之处在于，您可以通过更改要检查每次逐出的样本数来调整算法的精度。此参数由以下配置指令控制：

maxmemory-samples 5
redis 不使用真正的 LRU 实现的原因是因为它 消耗更多内存。但是，对于 使用 redis 的应用程序。此图比较 具有真实 LRU 的 redis 使用的 LRU 近似值。

LRU 比较

生成上述图形的测试用给定数量的密钥填充了 redis 服务器。密钥是从第一个到最后一个访问的。第一个键是使用 LRU 算法逐出的最佳候选项。后来又添加了 50% 的密钥，以强制驱逐一半的旧密钥。

您可以在图表中看到三种点，形成三个不同的条带。

浅灰色条带是被驱逐的对象。
灰色条带是未被逐出的对象。
绿色条带是添加的对象。
在理论上的 LRU 实现中，我们预计，在旧密钥中，前半部分将过期。相反，redis LRU 算法只会以概率方式使旧密钥过期。

正如你所看到的，与 redis 2.8 相比，redis 3.0 在 5 个样本方面做得更好，但是 redis 2.8 仍然保留了最新访问的大多数对象。在 redis 3.0 中使用 10 的样本量，近似值非常接近 redis 3.0 的理论性能。

请注意，LRU 只是一个模型，用于预测将来访问给定密钥的可能性。此外，如果您的数据访问模式密切 类似于幂律，大多数访问都将在密钥集中 LRU近似算法可以很好地处理。

在仿真中，我们发现使用幂律访问模式，真正的 LRU 和 redis 近似值之间的差异很小或根本不存在。

但是，您可以将样本数量提高到 10，但代价是增加一些 CPU 用法来近似真实 LRU，并检查这是否使 缓存未命中率的差异。



### 新的 LFU 模式
从 redis 4.0 开始，可以使用最不常用的逐出模式。此模式可能效果更好（提供更好的 命中率/未命中率）在某些情况下。在 LFU 模式下，redis 将尝试跟踪 项目访问的频率，因此很少使用的项目被逐出。这意味着 使用的密钥通常有更高的机会保留在内存中。

要配置 LFU 模式，可以使用以下策略：

volatile-lfu在设置了过期的密钥中使用近似的 LFU 逐出。
allkeys-lfu使用近似 LFU 逐出任何密钥。
LFU 的近似值类似于 LRU：它使用一个称为 Morris 计数器的概率计数器来估计对象访问频率，每个对象仅使用几个位，并结合衰减周期，以便计数器随时间推移而减少。在某些时候，我们不再希望将密钥视为频繁访问的密钥，即使它们在过去也是如此，以便算法可以适应访问模式的转变。

该信息的采样方式与 LRU 的采样方式类似（如本文档的上一节所述）选择驱逐候选项。

然而，与 LRU 不同的是，LFU 具有某些可调参数：例如，多快 如果一个频繁的项目不再被访问，它是否应该降低等级？还可以调整莫里斯计数器范围，以更好地使算法适应特定用例。

默认情况下，redis 配置为：

使计数器饱和，大约有 100 万个请求。
每一分钟衰减一次计数器。
这些值应该是合理的值，并且已经过实验测试，但用户可能希望使用这些配置设置来选择最佳值。

有关如何调整这些参数的说明，请参阅源代码分发的示例文件。简而言之，它们是：redis.conf

lfu-log-factor 10
lfu-decay-time 1
衰减时间是显而易见的，它是计数器在采样并发现比该值更旧时应该衰减的分钟数。一个特殊的价值意味着：我们永远不会衰减计数器。0

计数器对数因子更改使频率计数器饱和所需的命中次数，该计数器正好在 0-255 范围内。系数越高，达到最大值所需的访问次数就越多。根据下表，系数越低，低访问计数器的分辨率越好：


