---
title: redis 内存淘汰策略
date: 2024-02-01 16:14:03
permalink: /pages/c6674a/
categories:
  - 后端技术
  - redis
tags:
  - 
author: 
  name: erlangtui
  link: https://github.com/erlangtui
---

redis 的内存淘汰策略是指<span style="color: red;">**在 redis 用于缓存的内存不足时，如何处理需要申请额外空间的数据**</span>；redis的内存淘汰策略的选取并不会影响过期的key的处理，过期策略用于处理过期的缓存数据；

### 常见的内存淘汰策略

* noeviction：当内存不足时，<span style="color: red;">**新写入操作会报错**</span>；
* allkeys-lru：当内存不足时，<span style="color: red;">**在所有的 key 中移除最近最少使用的 key**</span>；
* allkeys-lfu：当内存不足时，<span style="color: red;">**在所有的 key 中移除最不常用的 key**</span>；
* allkeys-random：当内存不足时，<span style="color: red;">**在所有的 key 中随机移除某个 key**</span>；
* volatile-lru：当内存不足时，<span style="color: red;">**在设置了过期时间的 key 中移除最近最少使用的 key**</span>；
* volatile-lfu：当内存不足时，<span style="color: red;">**在设置了过期时间的 key 中移除最不常用的 key**</span>；
* volatile-random：当内存不足时，<span style="color: red;">**在设置了过期时间的 key 中随机移除某个 key**</span>；
* volatile-ttl：当内存不足时，<span style="color: red;">**在设置了过期时间的 key 中离过期时间最近的 key**</span>；

如果没有设置过期时间的 key，则 volatile-lru、volatile-lfu、volatile-random 和 volatile-ttl 策略的行为类似于 noeviction；

### 淘汰策略的选择
* 如果访问某些 key 的频率远远高于其他元素，无论是否设置了过期时间，可以使用 allkeys-lru 策略；
* 如果连续循环访问所有的 key，并且期望分布是均匀时，无论是否设置了过期时间，可以使用 allkeys-random 策略；
* 如果有大量长期保留的数据，但同时也有一些低访问频率的数据，无论是否设置了过期时间，可以使用 allkeys-random 策略；
* 如果在创建 key 时设置了过期时间，有很多需要精确控制过期时间的数据，可以使用 volatile-ttl 策略；
* 如果在创建 key 时设置了过期时间，并且这些 key 对于淘汰顺序没有特别的要求，可以使用 volatile-random 策略；
* 如果在创建 key 时设置了过期时间，某些 key 只是临时数据，访问频率较低，可以使用 volatile-lru 策略；
* 如果在创建 key 时设置了过期时间，但是访问频率很低，可以使用 volatile-lfu 策略；

### 近似 LRU 算法
* redis LRU 算法采从一池子的候选人中进行淘汰，提高了算法的性能，能够更接近真实 LRU 算法的行为，可以通过更改每次要检查的淘汰样本数来调整算法的精度；
* redis LRU 算法是一种近似的 LRU 的算法，因为真正的 LRU 算法会消耗更多的内存；

### 新的 LFU 模式
从 redis 4.0 开始，可以使用最不常用的逐出模式。此模式可能效果更好（提供更好的 命中率/未命中率）在某些情况下。在 LFU 模式下，redis 将尝试跟踪 项目访问的频率，因此很少使用的项目被逐出。这意味着 使用的密钥通常有更高的机会保留在内存中。

要配置 LFU 模式，可以使用以下策略：

volatile-lfu在设置了过期的密钥中使用近似的 LFU 逐出。
allkeys-lfu使用近似 LFU 逐出任何密钥。
LFU 的近似值类似于 LRU：它使用一个称为 Morris 计数器的概率计数器来估计对象访问频率，每个对象仅使用几个位，并结合衰减周期，以便计数器随时间推移而减少。在某些时候，我们不再希望将密钥视为频繁访问的密钥，即使它们在过去也是如此，以便算法可以适应访问模式的转变。

该信息的采样方式与 LRU 的采样方式类似（如本文档的上一节所述）选择驱逐候选项。

然而，与 LRU 不同的是，LFU 具有某些可调参数：例如，多快 如果一个频繁的项目不再被访问，它是否应该降低等级？还可以调整莫里斯计数器范围，以更好地使算法适应特定用例。

默认情况下，redis 配置为：

使计数器饱和，大约有 100 万个请求。
每一分钟衰减一次计数器。
这些值应该是合理的值，并且已经过实验测试，但用户可能希望使用这些配置设置来选择最佳值。

有关如何调整这些参数的说明，请参阅源代码分发的示例文件。简而言之，它们是：redis.conf

lfu-log-factor 10
lfu-decay-time 1
衰减时间是显而易见的，它是计数器在采样并发现比该值更旧时应该衰减的分钟数。一个特殊的价值意味着：我们永远不会衰减计数器。0

计数器对数因子更改使频率计数器饱和所需的命中次数，该计数器正好在 0-255 范围内。系数越高，达到最大值所需的访问次数就越多。根据下表，系数越低，低访问计数器的分辨率越好：


