---
title: go sync.Pool
date: 2023-11-30 23:28:56
permalink: /pages/261bb9/
categories:
  - 语言
  - Go
tags:
  - sync
author: 
  name: erlangtui
  link: https://github.com/erlangtui
---
::: tip
本文代码基于 go1.17.13，sync/pool.go、sync/poolqueue.go
:::

## 一、简述
* Pool 是一组可以单独保存和检索的临时对象的集合，可以缓存已分配但未使用的对象供以后重用，从而减轻垃圾回收器的压力；
* Pool 中有对象时，直接取出使用，Pool 中没有对象时，立即构建新的对象，从而使对象的分配开销得以摊销，并且是多线程安全的；
* fmt 包是使用 Pool 的一个很好示例，它维护一个动态大小的临时输出缓冲区存储，当许多 goroutine 打印时缓冲区变大，静止时变小；
* Pool 首次使用后不得被复制；

## 二、基本原理
* 根据当前 P 的个数，即默认是 CPU 核数或是用户自定义的核数，Pool 为每个 P 分配一个私有对象和共享对象的结构体，下图中 `poolLocalInternal`，多个`poolLocalInternal`结构体组成一个数组；
  * 私有对象可以直接存储该 Pool 需要存储的临时对象，每个 P 都只能对自己的私有对象进行存取，无权访问其他 P 的私有对象；
  * 共享对象是一个双端队列，队列的元素是一个个长度为 2 的幂的环，且后一个是前一个的两倍长，环中存储的也是 Pool 需要存储的临时对象，如下图中右侧的环；
  * 对于共享对象的双端队列，生产者可以从头部的环存取临时对象，消费者只能从尾部的环取临时对象，即每个 P 可以对自己的共享对象的双端队列头部进行读取，对其他 P 的共享对象的双端队列的尾部进行取；
  * 每个 P 都是自己共享对象的生产者，都是其他 P 共享对象的消费者，如下图中 P0 能够从自己的 share 所指向的队列的 head 处进行读写数据，P1、P2、P3 只能从 P0 的 share 所指向的队列的 tail 处读数据；
* 根据 GMP 模型，每个 P 上可以运行多个 G，在 G 需要去 Pool 中存取临时对象时，会将 G 与 P 绑定，并按照 P 的序号去数组中取其对应的结构体对象，这样避免了多线程之间的竞争；

![sync-pool](https://jsd.cdn.zzko.cn/gh/erlangtui/img-bed@master/go/sync-pool.53s0d4fij474.png)

## 三、基本用法
::: details
```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	// 创建一个 Pool
	var pool = &sync.Pool{
		New: func() interface{} {
			fmt.Println("Creating a new object.")
			return struct{}{}
		},
	}

	// 获取一个对象
	obj := pool.Get()

	// 使用对象
	// ...

	// 将对象放回 Pool 中
	pool.Put(obj)

	// 再次获取对象，这次将重用之前放回的对象
	obj2 := pool.Get()

	// 使用对象
	// ...

	// 将对象放回 Pool 中
	pool.Put(obj2)
}
```
:::
* 在创建`Pool`对象时，需要给`New`元素赋一个函数，该函数能够创建`Pool`中需要存储的对象，用于从`Pool`中取不到临时对象时调用；
* 从`Pool`中取出临时对象后，使用完毕时，仍然可以放回去，供其他 P 使用；

## 四、源码解读
### （一）双端链表
#### 1，poolDequeue
##### (1) poolDequeue
::: details
```go
type poolDequeue struct {
	headTail uint64

	vals []eface
}

type eface struct {
	typ, val unsafe.Pointer
}
const dequeueBits = 32
const dequeueLimit = (1 << dequeueBits) / 4

// dequeueNil 在 poolDequeue 中表示 interface{}(nil).
// 由于我们使用 nil 来表示空插槽，因此我们需要一个哨兵值来表示 nil，以区分空槽与空值。
type dequeueNil *struct{}
```
:::
* `poolDequeue` 是一个无锁、固定大小的单生产者、多消费者队列，生产者可以从头部读写，消费者从尾部读；它有一个附加功能，即剔除未使用的插槽，以避免不必要的对象保留；
* `headTail` 将一个 32 位头部索引和一个 32 位尾部索引打包在一起进行存储；
  * tail 队列中最老数据的索引，永远在前面；
  * head 将要填充的下一个槽的索引，永远在后面；
  * 槽的范围是 [tail, head) ；
  * 队列为空时，head == tail；队列满了时，tail + len(vals) == head，dequeueLimit 保证其不会越界；
  * head，tail 不会在超过队列长度时被赋值为其求余后的值，而是在要需要通过其取值时，用其对len(vals)求余后的余值作为索引；
* `vals` 是一个存储 `interface{}` 的切片，它的长度必须是 2 的幂，与索引 head、tail 一起形成一个环形队列；
* `eface` 为切片实际存储的元素，包含了指向元素类型和元素值的两个指针；
* `dequeueLimit` 表示切片的最大长度，这样能够保证 head、tail 不会超过机器的限制；
* `dequeueNil` 表示 `eface` 切片的一个空值，以与整个 `eface` 切片为空时的 `nil` 区分开；
##### (2) poolDequeue.unpack
::: details
```go
func (d *poolDequeue) unpack(ptrs uint64) (head, tail uint32) {
	const mask = 1<<dequeueBits - 1
	head = uint32((ptrs >> dequeueBits) & mask) // 右移 32 位后与 32 个 1 与运算，并 32 位截断
	tail = uint32(ptrs & mask)                  // 与 32 个 1 与运算后，32 位截断
	return
}
```
:::
* 从 64 位 ptrs 中解出 32 位 head, tail 值；

##### (3) poolDequeue.pack
::: details
```go
func (d *poolDequeue) pack(head, tail uint32) uint64 {
	const mask = 1<<dequeueBits - 1
	return (uint64(head) << dequeueBits) |
		uint64(tail&mask)
}
```
:::
* 将 32 位 head, tail 值打包为 64 位值；

##### (4) poolDequeue.pushHead
::: details
```go
// pushHead 在队列头部添加 val，如果队列已满，则返回false，必须被单生产者调用
func (d *poolDequeue) pushHead(val interface{}) bool {
	ptrs := atomic.LoadUint64(&d.headTail)
	head, tail := d.unpack(ptrs)
	if (tail+uint32(len(d.vals)))&(1<<dequeueBits-1) == head {
		// 队列已满
		return false
	}
	slot := &d.vals[head&uint32(len(d.vals)-1)]

	// 检查 popTail 是否释放了头插槽
	typ := atomic.LoadPointer(&slot.typ)
	if typ != nil {
		// 当前槽不为空，插入后会形成覆盖，说明另一个 goroutine 仍在清理尾部，因此队列实际上仍然已满。
		return false
	}

	// head 索引处的插槽为空，可以插入数据
	if val == nil {
		// 待插入的数据为 nil 时，设置为 dequeueNil，以区分空槽与空值
		val = dequeueNil(nil)
	}
	*(*interface{})(unsafe.Pointer(slot)) = val

	// 增加 head，这会将插槽的所有权传递给 popTail，并充当写入插槽的存储屏障。
	atomic.AddUint64(&d.headTail, 1<<dequeueBits)
	return true
}
```
:::
##### (5) poolDequeue.popHead
::: details
```go
// popHead 移除并返回队列首部的元素
// 如果队列为空，则返回 false，必须由但生产者调用
func (d *poolDequeue) popHead() (interface{}, bool) {
	var slot *eface
	for {
		ptrs := atomic.LoadUint64(&d.headTail)
		head, tail := d.unpack(ptrs)
		if tail == head {
			// 头尾相等，队列为空
			return nil, false
		}

		// 确认尾部并递减头。我们在读取值之前执行此操作，以收回此插槽的所有权。
		head--
		ptrs2 := d.pack(head, tail)
		if atomic.CompareAndSwapUint64(&d.headTail, ptrs, ptrs2) {
			// 成功回收插槽，head 对应的是将要插入的值的索引，减减后才是实际上要弹出的值
			slot = &d.vals[head&uint32(len(d.vals)-1)]
			break
		}
	}

	val := *(*interface{})(unsafe.Pointer(slot))
	if val == dequeueNil(nil) {
		val = nil
	}
	// 将插槽归零，避免在 pushHead 时发现不为 nil。
	// 与 popTail 不同的是，这不是与 pushHead 竞争，所以我们在这里不需要小心。
	*slot = eface{}
	return val, true
}
```
:::
##### (6) poolDequeue.popTail
::: details
```go
// popTail 移除并返回队列尾部的元素
// 如果队列为空，则返回 false，可以被任意数量的消费者调用
func (d *poolDequeue) popTail() (interface{}, bool) {
	var slot *eface
	for {
		ptrs := atomic.LoadUint64(&d.headTail)
		head, tail := d.unpack(ptrs)
		if tail == head {
			// 头尾相等，队列为空
			return nil, false
		}

		// 增加尾部
		ptrs2 := d.pack(head, tail+1)
		if atomic.CompareAndSwapUint64(&d.headTail, ptrs, ptrs2) {
			// 成功拥有尾部的插槽
			slot = &d.vals[tail&uint32(len(d.vals)-1)]
			break
		}
	}

	// We now own slot.
	val := *(*interface{})(unsafe.Pointer(slot))
	if val == dequeueNil(nil) {
		val = nil
	}

	// 告诉pushHead，我们已经用完了这个插槽。将槽置零也很重要，这样我们就不会留下可能使该对象存活时间超过必要时间的引用。
	// 我们首先写入 val，然后通过原子写入 typ 来发布我们已经完成了这个插槽。
	slot.val = nil
	atomic.StorePointer(&slot.typ, nil)
	// At this point pushHead owns the slot.

	return val, true
}
```
:::
#### 2，poolChainElt
::: details
```go
// poolChainElt 是一个双向链表，只是链表的每个元素都是一个环形队列 poolDequeue，每个 poolDequeue 队列的长度都是 2 幂，并且是前一个队列长度的两倍
type poolChainElt struct {
	poolDequeue

	// next、prev 链接到 poolChain 相邻的 poolChainElts
	// next 指向的方向为 head，由生产者以原子方式编写，由消费者以原子方式读取。它只从 nil 过渡到非 nil。
	// prev 指向的方向为 nil，由消费者以原子方式编写，由生产者以原子方式读取。它只从非 nil 过渡到 nil。
	// 当前 P 上的 G 对于该 P 上的 poolDequeue 是生产者，从 next 上写和读，对于其他 P 上的 poolDequeue 是消费者，只能从 prev 读，不能写；
	next, prev *poolChainElt
}
```
:::

#### 3，poolChain
::: details
```go
// poolChain 是 poolDequeue 动态长度的版本
// 这是作为 poolDequeues 的双向链表队列实现的，其中每个队列的大小是前一个队列的两倍。
// 一旦排队填满，就会分配一个新的，并且只会推送到最新的排队。
// 弹出发生在列表的另一端，一旦排队用尽，它就会从列表中删除。
type poolChain struct {
	// head 是要从头部推入的 poolDequeue。这只能由生产者访问，因此不需要同步。所以 head 指向的是最新创建的队列，也是最大的队列。
	head *poolChainElt
	// tail 是要从尾部弹出的 poolDequeue。它由消费者访问，因此读取和写入必须是原子的。tail 指向的是最早创建的队列，也就是最小的队列。
	tail *poolChainElt

	// P1 作为生产者从 P1 的头部开始读，其他 P 作为消费者，从 P1 的尾部开始读，他们与 P1 之间不会产生竞争，但是他们之间会有竞争
	// 故头部读不用原子操作，尾部读需要用原子操作
}
```
:::
### 2，缓存池