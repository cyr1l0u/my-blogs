---
title: Safe map
date: 2023-10-20 15:20:27
permalink: /pages/6855f1/
categories:
  - 语言
  - Go
tags:
  - 
author: 
  name: erlangtui
  link: https://github.com/erlangtui
---

## 一、基本原理
* Map 类似于 Go `map[interface{}]interface{}` 以哈希表的方式存储键值对，但可以安全地由多个 goroutines 并发使用，无需额外的加锁；
* 传统的 map 需要对整个 map 加锁，才能解决并发安全的问题，锁的粒度较大；
* **Map 主要是以空间换时间，对读的部分采用原子操作和原子计数，对写的部分采用互斥锁，通过读写分离来降低锁的粒度，从而提高读写效率，适用于写少读多的场景**；
* Map 类型针对两种常见用例进行了优化：
  * （1）当给定 key 的值，只写入一次但读取多次时，例如不断增长的缓存类应用；
  * （2）当多个 goroutine 读取、写入和覆盖不相交的 key 的值时；
* 在这两种情况下，与单独的 Mutex 或 RWMutex 配对的 Go map 相比，使用 Map 可以显著减少锁竞争；

## 二、基本用法
### 1，Map
```go
type Map struct {
	mu      Mutex
	read    atomic.Value
	dirty   map[interface{}]*entry
	misses  int
}
```
* Map 是一个结构体类型，其内部字段都是私有的，不可直接访问；
* **Map 在首次使用后不得复制**；
* 使用时可像其他类型一样直接使用，不用单独加锁，如：`var m sync.Map` ；
* **Map 没有重载 `[]` 运算符，不能直接以 `m[key]` 的方式访问或修改 m 中的元素**； 

### 2，Load
* `func (m *Map) Load(key interface{}) (value interface{}, ok bool)`
* Load 返回存储在 map 中 key 键对应的值，如果不存在该键值，则返回 nil。ok 表示是否在 map 中找到该 key 对应的值；
* 如：`val, ok := m.Load("aaa")` ；

### 3，Store
* `func (m *Map) Store(key, value interface{})`
* Store 将 key、value 这个键值对存到 m 中；
* 如：`m.Store("aaa", 111)` ；

### 4，LoadOrStore
* `func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)`
* LoadOrStore 返回存储在 map 中 key 键对应的值，如果不存在该键值，则将 key、value 这个键值对存到 m 中；
* 如果找到了 key 对应的值，则 loaded 结果为 true，否则为 false；
* 如：`val, ok := m.LoadOrStore("aaa", 111)` ；

### 5，LoadAndDelete
* `func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool)`
* LoadAndDelete 删除键的值，并返回以前的值（如果有），loaded 表示 key 对应的值是否存在；
* 如：`val, ok := m.LoadAndDelete("aaa", 111)` ；

### 6，Delete
* `func (m *Map) Delete(key interface{})`
* Delete 删除 key 对应的值；
* 如：`m.Delete("aaa")` ；

### 7，Range
* `func (m *Map) Range(f func(key, value interface{}) bool)`
* Range 遍历 m 中的键值对，并调用 f 函数对键值对进行处理，**当 f 返回 false 时，停止遍历**；
* 如：
  ```go
	m.Range(func(key, value interface{}) bool {
		k := key.(string)
		val := value.(int)
		if k == "aaa" {
			fmt.Println(k, val)
			return false
		}
		return true
	})
  ```

## 三、源码解读
### 1，Map
```go
type Map struct {
	mu Mutex

	// read 包含映射内容中可安全并发访问的部分（保留或不保留 MU）。read 字段本身始终可以安全加载，但只能与 mu 一起存储。
	// 存储在 read 中的条目可以在没有 mu 的情况下同时更新，但更新以前删除的条目需要将该条目复制到 dirty map 中，并在保留 mu 的情况下取消删除。
	read atomic.Value // 存储 readOnly 结构体类型

	// dirty 包含 map 中需要保留 MU 的部分。为了确保 dirty map 可以快速提升为 read map，它还包括 read map 中所有未删除的条目。
	// 删除的条目不会存储在 dirty 中。清理 map 中已清除的条目必须取消删除并添加到 dirty map 中，然后才能将新值存储到 dirty map 中。
	// 如果 dirty 为 nil，则下次写入映射时将通过创建干净映射的浅拷贝来初始化它，省略过时的条目。
	dirty map[interface{}]*entry

	// misses 计算自上次更新 read map 以来需要锁定 MU 以确定 key 是否存在的负载数。
	// 一旦 misses 足够支付复制 dirty map 的成本，dirty map 将被提升为 read map（处于未修改状态），map 的下一个存储将创建一个新的 dirty 副本。
	misses int // 加锁则计数，查询dirty时需要加锁
}
```
* Map 是一个结构体类型，其内部字段都是私有的，不可直接访问；
* mu 字段，互斥锁类型，当写 read map 或者读写 dirty map 时，需要加互斥锁
* read 字段，原子类型，存储 readOnly 结构体类型的变量，存储的