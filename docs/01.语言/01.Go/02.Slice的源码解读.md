---
title: Slice的源码解读
date: 2023-08-13 22:25:42
permalink: /pages/d78959/
categories:
  - 语言
  - Go
tags:
  - 
author: 
  name: erlangtui
  link: https://github.com/erlangtui
---

::: tip
本文代码基于 go1.17.13，runtime/slice.go
:::
## 一、Slice 的数据结构
```go
type slice struct {
	array unsafe.Pointer // 数组指针，其值为实际存储数据的数组首地址
	len   int            // 长度，该切片实际存储数据的长度
	cap   int            // 容量，该切片在不扩容的情况下能够存储的数据长度
}
```
* Slice 的数据结构是一个包含了 **数组指针、长度、容量** 的结构体；
* 在对 Slice 进行复制、传参等操作时，进行的是**值复制**，即复制的整个`slice`结构体；
* 复制时包含了，数组指针、长度和容量，是一次**浅拷贝**，没有对数组指针指向的数组中的数据进行逐一复制；
* 所以<span style="color: blue;">**在数组指针的值不改变的情况下，对 Slice 切片元素的修改仍然会影响原切片的数组**</span>，见后面示例1；
* 如果<span style="color: blue;">**复制后的数组指针发生了改变，如发生了扩容，那么对复制后的切片元素进行修改不会影响到原切片的数组**</span>，见后面示例2；
* 如果<span style="color: blue;">**新的切片是原先切片的一部分，那么修改新的切片可能会影响到原先的切片**</span>，见后面示例3；

## 二、编译过程
```go
package main

import "fmt"

func main() {
	s := make([]int, 0, 1)
	s = append(s, 1)
	s = append(s, 2)
	fmt.Println(s) // 必须对 s 进行调用，才能看到编译的输出
}
```
::: details
```sh
"".main STEXT size=256 args=0x0 locals=0x68 funcid=0x0
	0x0000 00000 (main.go:5)	TEXT	"".main(SB), ABIInternal, $112-0
	0x0000 00000 (main.go:5)	MOVD	16(g), R1
	0x0004 00004 (main.go:5)	PCDATA	$0, $-2
	0x0004 00004 (main.go:5)	MOVD	RSP, R2
	0x0008 00008 (main.go:5)	CMP	R1, R2
	0x000c 00012 (main.go:5)	BLS	232
	0x0010 00016 (main.go:5)	PCDATA	$0, $-1
	0x0010 00016 (main.go:5)	MOVD.W	R30, -112(RSP)
	0x0014 00020 (main.go:5)	MOVD	R29, -8(RSP)
	0x0018 00024 (main.go:5)	SUB	$8, RSP, R29
	0x001c 00028 (main.go:5)	FUNCDATA	ZR, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x001c 00028 (main.go:5)	FUNCDATA	$1, gclocals·f207267fbf96a0178e8758c6e3e0ce28(SB)
	0x001c 00028 (main.go:5)	FUNCDATA	$2, "".main.stkobj(SB)
	0x001c 00028 (main.go:6)	MOVD	$type.int(SB), R0
	0x0024 00036 (main.go:6)	MOVD	R0, 8(RSP)
	0x0028 00040 (main.go:6)	MOVD	ZR, 16(RSP)
	0x002c 00044 (main.go:6)	MOVD	$1, R1
	0x0030 00048 (main.go:6)	MOVD	R1, 24(RSP)
	0x0034 00052 (main.go:6)	PCDATA	$1, ZR
	0x0034 00052 (main.go:6)	CALL	runtime.makeslice(SB)
	0x0038 00056 (main.go:6)	MOVD	32(RSP), R0
	0x003c 00060 (main.go:7)	MOVD	$1, R1
	0x0040 00064 (main.go:7)	MOVD	R1, (R0)
	0x0044 00068 (main.go:8)	MOVD	$type.int(SB), R2
	0x004c 00076 (main.go:8)	MOVD	R2, 8(RSP)
	0x0050 00080 (main.go:8)	MOVD	R0, 16(RSP)
	0x0054 00084 (main.go:8)	MOVD	R1, 24(RSP)
	0x0058 00088 (main.go:8)	MOVD	R1, 32(RSP)
	0x005c 00092 (main.go:8)	MOVD	$2, R0
	0x0060 00096 (main.go:8)	MOVD	R0, 40(RSP)
	0x0064 00100 (main.go:8)	CALL	runtime.growslice(SB)
	0x0068 00104 (main.go:8)	MOVD	48(RSP), R0
	0x006c 00108 (main.go:8)	MOVD	56(RSP), R1
	0x0070 00112 (main.go:8)	MOVD	64(RSP), R2
	0x0074 00116 (main.go:8)	MOVD	$2, R3
	0x0078 00120 (main.go:8)	MOVD	R3, 8(R0)
	0x007c 00124 (main.go:9)	MOVD	R0, 8(RSP)
	0x0080 00128 (main.go:8)	ADD	$1, R1, R0
	0x0084 00132 (main.go:9)	MOVD	R0, 16(RSP)
	0x0088 00136 (main.go:9)	MOVD	R2, 24(RSP)
	0x008c 00140 (main.go:9)	CALL	runtime.convTslice(SB)
	0x0090 00144 (main.go:9)	MOVD	32(RSP), R0
	0x0094 00148 (main.go:9)	STP	(ZR, ZR), ""..autotmp_11-16(SP)
```
:::
* 对以上代码进行编译，执行 `go tool compile -S main.go`，会得到上面的输出；
* 会发现第六行调用了 `runtime.makeslice` 函数，创建了切片；
* 第八行调用了 `runtime.growslice` 进行了扩容；

## 三、重要函数
### 1，makeslice 函数
* 在创建 Slice 时，主要是对要分配的**内存地址大小、内存大小**、长度和容量进行了判断；
::: details
```go
func panicmakeslicelen() {
	panic(errorString("makeslice: len out of range"))
}

func panicmakeslicecap() {
	panic(errorString("makeslice: cap out of range"))
}

func makeslice(et *_type, len, cap int) unsafe.Pointer {
	// Slice 的元素大小乘以容量
	mem, overflow := math.MulUintptr(et.size, uintptr(cap))
	if overflow || mem > maxAlloc || len < 0 || len > cap {
		// 判断是否需要分配的内存地址超过最大值、内存超过了最大分配内存等
		mem, overflow := math.MulUintptr(et.size, uintptr(len))
		if overflow || mem > maxAlloc || len < 0 {
			panicmakeslicelen()
		}
		panicmakeslicecap()
	}

	return mallocgc(mem, et, true)
}
```
:::
### 2，growslice 函数


## 示例
### 示例1：修改复制后的切片影响原来的切片

<span>创建切片 s，并传递给函数 `test`，test 函数中的切片 t 是 main 函数中切片 s 的副本，其字段 array 的值是一样的。也就是说，切片 s 和 t，共用的是同一个底层数组，那么在函数 test 中对切片 t 的存储的值进行修改，同时也会反馈到切片 s，所以在 main 函数中再次打印 s 时，会发现其存储的值发生了改变。</span>

```go
package main

import (
	"log"
	"unsafe"
)

func test(t []int) {
	log.Printf("t, vals: %v, array: %v\n", t, *(**int)(unsafe.Pointer(&t)))
	t[0] = 9
	log.Printf("t, vals: %v, array: %v\n", t, *(**int)(unsafe.Pointer(&t)))
}

func main() {
	s := make([]int, 0, 1)
	s = append(s, 11)
	log.SetFlags(log.Lshortfile)
	log.Printf("s, vals: %v, array: %v\n", s, *(**int)(unsafe.Pointer(&s))) // 对 array 取值，其值是数组的地址
	test(s)
	log.Printf("s, vals: %v, array: %v\n", s, *(**int)(unsafe.Pointer(&s)))
}
/*
output:
main.go:18: s, vals: [11], array: 0x1400001e068
main.go:9: t, vals: [11], array: 0x1400001e068
main.go:11: t, vals: [9], array: 0x1400001e068
main.go:20: s, vals: [9], array: 0x1400001e068
*/

```