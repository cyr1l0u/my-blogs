---
title: go 普通方法与接口方法
date: 2024-03-24 21:34:13
permalink: /pages/2b4b30/
categories:
  - 语言
  - Go
tags:
  - 
author: 
  name: erlangtui
  link: https://github.com/erlangtui
---

## 一，基本介绍
- 方法可以理解为是被指定了参数类型的函数，这个类型的参数通常叫做接收者；
- 方法能给用户自定义的类型添加新的行为，它和函数的区别在于方法有一个接收者；


## 二、方法接收者的类型

- 方法的接收者可以是值接收者，也可以是指针接收者 ；
- 在调用方法的时候，**不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型**；
- 值类型的调用方既可以调用值接收者的方法，也可以调用指针接收者的方法；
- 指针类型的调用方既可以调用指针接收者的方法，也可以调用值接收者的方法。
## 2，普通方法
```go
package main

import "fmt"

type Person struct {
	age int
}

func (p Person) howOld() int {
	return p.age
}

func (p *Person) growUp() {
	p.age += 1
}

func main() {
	// qcrao 是值类型
	qcrao := Person{age: 18}

	// 值类型 调用接收者也是值类型的方法
	fmt.Println(qcrao.howOld()) // 18

	// 值类型 调用接收者是指针类型的方法
	qcrao.growUp()
	fmt.Println(qcrao.howOld()) // 19

	// ----------------------

	// stefno 是指针类型
	stefno := &Person{age: 100}

	// 指针类型 调用接收者是值类型的方法
	fmt.Println(stefno.howOld()) // 100 

	// 指针类型 调用接收者也是指针类型的方法
	stefno.growUp()
	fmt.Println(stefno.howOld()) // 101
}
```
| - | 值接收者 | 指针接收者 |
| --- | --- | --- |
| 值类型调用者 | 方法会使用调用者的一个副本，类似于“传值” | 使用值的引用来调用方法，上例中，qcrao.growUp() 实际上是 (&qcrao).growUp() |
| 指针类型调用者 | 指针被解引用为值，上例中，stefno.howOld() 实际上是 (*stefno).howOld() | 实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，**拷贝了一份指针** |


## 二、实现接口的方法
:::danger

- 实现了接收者是**值类型**的方法，相当于**自动实现了接收者是指针类型**的方法；
- 实现了接收者是**指针类型**的方法，不会自动生成对应接收者是值类型的方法；
:::
```go
package main

import "fmt"

type coder interface {
	code()
	debug()
}

type Gopher struct {
	language string
}

func (p Gopher) code() {
	fmt.Printf("I am coding %s language\n", p.language)
}

func (p *Gopher) debug() {
	fmt.Printf("I am debuging %s language\n", p.language)
}

func f1() {
	var c coder = &Gopher{"Go"}
	c.code()
	c.debug()
}

func f2() {
	var c coder = Gopher{"Go"} // 此处编译出错 
	c.code()
	c.debug()
}

func main() {
	f1()
	f2()
}
```
| - | 结构体实现接口 | 结构体指针实现接口 |
| --- | --- | --- |
| 结构体初始化变量 | 通过 | 不通过 |
| 结构体指针初始化变量 | 通过 | 通过 |

:::success

- 接收者是指针类型的方法，很可能在方法中会对接收者的属性进行更改操作，从而影响接收者；
- 接收者是值类型的方法，在方法中不会对接收者本身产生影响；
- 当实现了一个接收者是值类型的方法，可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者；
- 当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为**值类型会产生一个拷贝，不会真正影响调用者；**
- **如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法；**
- **指针变量副本**与原来的指针指向一个**相同并且唯一的结构体**，所以编译器可以**隐式的对变量解引用**获取指针指向的结构体；
- 如果实现了接收者是指针类型的方法，当传入一个结构体值时，**这个结构体是原始结构体的副本**，**即使能够生成一个结构体指针，也是指向副本的指针**，无法对原始结构体产生改变；
:::

## 三、两者的区别

- 普通方法：
   - **接收者是指针类型的方法，也能接受调用者是值类型的调用**，使用了调用者值的引用来调用方法；
- 接口方法：
   - **接收者是指针类型的方法，无法接受调用者是值类型的调用**，默认没有实现值类型的方法，因为值类型的方法修改的是调用者的副本，无法对原始调用者进行修改；
## 四、使用场景

- 如果方法的接收者是值类型，无论调用者是对象还是对象指针，**修改的都是对象的副本**，不影响调用者；
- 如果方法的接收者是指针类型，则调用者修改的是**指针指向的对象本身**；
- 使用指针作为方法的接收者的理由：
- 方法能够修改接收者指向的值；
- 避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效；

## 五、检测接口的实现

- 使用结构体时并不关心它实现了哪些接口，Go 语言只会在**传递参数、返回参数以及变量赋值**时才会对某个类型是否实现接口进行检查；
- 编译器能够检测接口的方法是否已经实现；
- 赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数；
```go
package main

import "io"

type myWriter struct {

}

/*func (w myWriter) Write(p []byte) (n int, err error) {
	return
}*/

func main() {
    // 检查 *myWriter 类型是否实现了 io.Writer 接口
    var _ io.Writer = (*myWriter)(nil)

    // 检查 myWriter 类型是否实现了 io.Writer 接口
    var _ io.Writer = myWriter{}
}
```


::: details
```go
package main

import "fmt"

type person struct {
	age int
}

func (p *person) getAge() int {
	return p.age
}

func (p *person) setAge(a int) {
	p.age = a
}

func main() {
	p1 := person{age: 18}

	// 值类型 调用接收者也是值类型的方法
	fmt.Println(p1.getAge()) // 18

	// 值类型 调用接收者是指针类型的方法
	p1.setAge(19)
	fmt.Println(p1.getAge()) // 19

	// ----------------------

	// p2 是指针类型
	p2 := &person{age: 100}

	// 指针类型 调用接收者是值类型的方法
	fmt.Println(p2.getAge()) // 100

	// 指针类型 调用接收者也是指针类型的方法
	p2.setAge(99)
	fmt.Println(p2.getAge()) // 99
}
```
:::


::: details
```go
package main

type user interface {
	get() string
	set(s string)
}

type gopher struct {
	name string
}

func (g gopher) get() string {
	return g.name
}

func (g *gopher) set(s string) {
	g.name = s
}

func f1() {
	var c user = &gopher{"go1"}
	c.get()
	c.set("f1")
}

func f2() {
	var c user = gopher{"go2"} // 此处编译出错
	c.get()
	c.set("f2")
}

func main() {
	f1()
	f2()
}
```
:::

::: danger
./main.go:27:6: cannot use gopher{...} (type gopher) as type user in assignment:
	gopher does not implement user (set method has pointer receiver)
:::