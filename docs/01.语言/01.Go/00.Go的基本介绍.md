---
title: Go 的基本介绍
date: 2023-10-09 14:30:53
permalink: /pages/a164c7/
# titleTag: 原创
# sticky: 1
categories:
  - Go
tags:
  - Go
author: 
  name: erlangtui
  link: https://github.com/erlangtui
---

## 一、数据类型
* go 是一种强类型语言，数据类型之间有着严格的区分；
* 常见的数据类型有：
  ```go
  bool // 布尔类型，值为 true or false

  uint8   // 无符号 8 位整形，范围 0 ~ 255
  uint16  // 无符号 16 位整形，范围 0 ~ 65535
  uint32  // 无符号 32 位整形，范围 0 ~ 4294967295
  uint64  // 无符号 64 位整形，范围 0 ~ 18446744073709551615
  uint    // 64 位机器上等于 uint64，32 位机器上等于 uint32

  int8  // 有符号 8 位整形，范围 -128 ~ 127   
  int16 // 有符号 16 位整形，范围 -32768 ~ 32767
  int32 // 有符号 32 位整形，范围 -2147483648 - 2147483647
  int64 // 有符号 64 位整形，范围 -9223372036854775808 ~ 9223372036854775807
  int   // 64 位机器上等于 int64，32 位机器上等于 int32

  float32 // 32 位浮点数，符合 IEEE-754 标准
  float64 // 64 位浮点数，符合 IEEE-754 标准

  string // 字符串类型，可以为空，字符不可改变

  complex64   // 64 位复数，实部和虚部都是 float32
  complex128  // 128 位复数，实部和虚部都是 float64

  uintptr // 整数类型，足够大，可以容纳任何指针的位模式

  byte // uint8 的别名，在所有方面都等同于 uint8，用于区分字节值和 8 位无符号整数值

  rune // int32 的别名，在所有方面都等同于 int32，用于区分字符值和整数值

  nil // 一个预先声明的标识符，表示指针、通道、func、接口、映射或切片类型的零值
  ```

## 二、数据结构
### 1, slice
* 切片，用于存储一组同类型数据；
* 底层主要是长度、容量、指向数组的指针组成，当触发扩容时，该指针的值会发生变化；

### 2, 数组
* 固定容量的切片，或是根据存储的数据长度自动推导容量大小；
* 没有 append 函数，不会触发扩容；
* 只能通过索引访问、修改、添加元素；

### 3, map
* 映射结构，用于存储 key、value 的键值对，key 的类型相同，value 的类型也要相同，key 和 value 类型可以不同；
* 底层主要是通过数组和哈希的方式实现，并通过链接地址法处理哈希冲突，同时 key 和 value 是分开存储的，以方便内存对齐和内存回收；
* 当 map 的负载因子达到一定值时会触发扩容；

### 4, struct
* 结构体类型，用于存储不同类型的数据；
* 空结构体的大小为 0；

### 5, interface
* 接口类型，用于定义对象的行为和方法集合；
* 接口提供了一种方式来实现多态性，允许不同的类型以不同的方式进行交互；
* 接口定义了一个或多个方法的签名，但没有具体的实现，任何类型只要实现了接口中定义的所有方法，就被认为是该接口类型的实现；
* 所有类型均是空接口的实现；

## 三、内置函数
### 1, append
* `func append(slice []Type, elems ...Type) []Type`；
* append 内置函数将元素追加到切片的末尾；
* 如果切片有足够的容量，则直接将新元素添加到底层数组；
* 如果没有，将触发扩容分配一个新的底层数组，此时指向数组的指针指会发生改变，append 返回更新后的切片；

### 2, copy
* `func copy(dst, src []Type) int`；
* copy 内置函数将元素从源切片复制到目标切片中；
* 作为特殊情况，它还会将字节从字符串复制到字节切片；
* 源和目标可能重叠，可能会出现意想不到的情况；
* copy 返回复制的元素数，即 len（src） 和 len（dst） 的最小值；

### 3, delete
* `delete(m map[Type]Type1, key Type)`；
* delete 内置函数从映射中删除具有指定键 `m[key]` 的元素。如果 `m` 为 `nil` 或没有此类元素，则 delete 为空操作。

### 4, len
* `func len(v Type) int`；
* len 内置函数根据其类型返回 v 的长度：
  * 数组或数组指针：v 中的元素数量；
  * slice 或 map：返回 v 中元素数量，如果 v 为 nil，则 len（v） 为零；
  * string：v 中的字节数；
  * channel：通道缓冲区中排队（未读）的元素数，如果 v 为 nil，则 len（v） 为零。

### 5, cap
* `func cap(v Type) int`；
* cap 内置函数根据其类型返回 v 的容量：
  * 数组或数组指针：v 中的元素数量；（与 len（v） 相同）；
  * slice：可以达到的最大长度，如果 v 为 nil，则 cap（v） 为零；
  * channel：通道缓冲区容量，如果 v 为 nil，则 cap（v） 为零；

### 6, new
* `func new(Type) *Type`；
* 用来分配内存，第一个参数是类型，而不是值，返回的值是指向该类型新分配的零值的指针；

### 7, make
* `func make(t Type, size ...IntegerType) Type`；
* 用来分配并初始化`slice、map、chan`类型的对象；
* 与 new 一样，第一个参数是类型，而不是值；与 new 不同的是，make 的返回类型与其参数的类型相同，而不是指向它的指针；
* 参数和结果的规范取决于创建的类型：
  * `slice`：size 指定长度，切片的容量等于其长度。可以提供第二个整数参数来指定不同的容量，必须不小于长度；
  * `map`：为空 map 分配足够的空间来容纳指定数量的元素，可以省略 size，在这种情况下，将分配较小的起始大小；
  * `chan`：通道的缓冲区使用指定的缓冲区容量进行初始化，如果为零或省略大小，则通道无缓冲；

### 8, close
* `func close(c chan<- Type)`；
* close 内置函数关闭通道，该通道必须是双向的或仅发送的；
* 通道应该只由发送方执行，而不是由接收方执行，并且具有在接收到最后一个发送的值后关闭通道的效果；
* 从关闭后的通道 c 接收到最后一个值后，c 的任何接收 goroutine 都将成功接收到通道元素的零值，而不会被阻塞；
* 对于关闭后的通道，x, ok := <-c 会将 ok 设置为 false；

### 9, panic
* `func panic(v interface{})`；
* panic 内置函数停止当前 goroutine 的正常执行；
* 当函数 F 调用 panic 时，F 的正常执行会立即停止，任何被 F 延迟执行的函数都以平常的方式运行，然后 F 返回给其调用方；
* 对于调用方 G，对 F 的调用就像对 panic 的调用一样，终止 G 的执行并运行任何延迟的函数；
* 这种情况一直持续到执行 goroutine 中的所有函数以相反的顺序停止为止，此时，程序将终止，并带有非零退出代码；
* 此终止序列称为 panicking，可通过内置函数 recover 进行捕获；

### 10, recover
* `func recover() interface{}`；
* recover 内置函数允许程序管理 goroutine 的 panic 行为，且只能捕获当前 goroutine，无法夸 goroutine；
* 在延迟函数（但不是它调用的任何函数）中执行恢复调用会通过恢复正常执行来停止 panic 序列，并检索传递给 panic 调用的错误值；
* 如果在延迟函数之外调用 recover，则不会停止 panic 序列，即 recover 只能在 defer 中执行，在其他作用域无效，且只能在与 panic 同级的 defer 函数中才有效，多级嵌套 defer 后，最里层的 recover 无法捕获外层的 panic；
* 当 goroutine 没有 panic ，或者 panic 的参数为 nil，则 recover 返回 nil；
* recover 的返回值能够说明 goroutine 是否处于 panic 状态；

### 11, print
* `func print(args ...Type)`；
* print 内置函数以特定地实现方式格式化其参数，并将结果写入标准错误；

### 12, println
* `func println(args ...Type)`；
* println 内置函数以特定地实现方式格式化其参数，并将结果写入标准错误；
* 始终在参数之间添加空格，并附加换行符；

### 13, complex
* `func complex(r, i FloatType) ComplexType`；
* complex 内置函数从两个浮点值构造一个复数值；
* 实部和虚部必须具有相同的大小，即 float32 或 float64；
* 并且返回值将是相应的复数类型（float32 为 complex64，float64 为 complex128）；

### 14, real
* `func real(c ComplexType) FloatType`；
* real 内置函数返回复数 c 的实数部分，返回值将是与 c 类型对应的浮点类型；

### 15, imag
* `func imag(c ComplexType) FloatType`；
* imag 内置函数返回复数 c 的虚部，返回值将是与 c 类型对应的浮点类型；

## 四、同步原语
### 1，Mutex
* 互斥锁，同一时刻只能被一个 goroutine 拥有；
* 写写、写读、读读均互斥；
### 2，RWMutex
* 读写锁，同一时刻只能被一个写 goroutine 拥有，或同时被多个读 goroutine 拥有；
* 写写、写读互斥，读读不互斥；
### 3, WaitGroup
* 用于等待一组 goroutine 的返回，例如并发请求后等待结果返回再统一处理；
### 4，Once
* 用于保证运行期间，某段代码只执行一次，例如初始化某个配置；
### 5, Cond

### 6, Pool

### 7, atomic

## 五、关键字
### 1, for

### 2, range

### 3, defer

### 4, select

### 5, channel

### 6, reflect

::: tip
持续更新中……
:::