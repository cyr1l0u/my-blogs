---
title: Go的基本介绍
date: 2023-07-02 14:30:53
permalink: /pages/a164c7/
# titleTag: 原创
# sticky: 1
categories:
  - Go
tags:
  - Go
author: 
  name: erlangtui
  link: https://github.com/erlangtui
---

## 一、数据类型
* go 是一种强类型语言，数据类型之间有着严格的区分；
* 常见的数据类型有：
  ```go
  bool // 布尔类型，值为 true or false

  uint8   // 无符号 8 位整形，范围 0 ~ 255
  uint16  // 无符号 16 位整形，范围 0 ~ 65535
  uint32  // 无符号 32 位整形，范围 0 ~ 4294967295
  uint64  // 无符号 64 位整形，范围 0 ~ 18446744073709551615
  uint    // 64 位机器上等于 uint64，32 位机器上等于 uint32

  int8  // 有符号 8 位整形，范围 -128 ~ 127   
  int16 // 有符号 16 位整形，范围 -32768 ~ 32767
  int32 // 有符号 32 位整形，范围 -2147483648 - 2147483647
  int64 // 有符号 64 位整形，范围 -9223372036854775808 ~ 9223372036854775807
  int   // 64 位机器上等于 int64，32 位机器上等于 int32

  float32 // 32 位浮点数，符合 IEEE-754 标准
  float64 // 64 位浮点数，符合 IEEE-754 标准

  string // 字符串类型，可以为空，字符不可改变

  complex64   // 64 位复数，实部和虚部都是 float32
  complex128  // 128 位复数，实部和虚部都是 float64

  uintptr // 整数类型，足够大，可以容纳任何指针的位模式

  byte // uint8 的别名，在所有方面都等同于 uint8，用于区分字节值和 8 位无符号整数值

  rune // int32 的别名，在所有方面都等同于 int32，用于区分字符值和整数值

  nil // 一个预先声明的标识符，表示指针、通道、func、接口、映射或切片类型的零值
  ```
## 二、数据结构
### 1, slice
* 切片，用于存储一组同类型数据；
* 底层主要是长度、容量、指向数组的指针组成，当触发扩容时，该指针的值会发生变化；

### 2, map
* 映射结构，用于存储 key、value 的键值对，key 的类型相同，value 的类型也要相同，key 和 value 类型可以不同；
* 底层主要是通过数组和哈希的方式实现，并通过链接地址法处理哈希冲突，同时 key 和 value 是分开存储的，以方便内存对齐和内存回收；
* 当 map 的负载因子达到一定值时会触发扩容；

### 3, struct
* 结构体类型，用于存储不同类型的数据；
* 空结构体的大小为 0；

### 4, interface
* 接口类型，用于定义对象的行为和方法集合；
* 接口提供了一种方式来实现多态性，允许不同的类型以不同的方式进行交互；
* 接口定义了一个或多个方法的签名，但没有具体的实现，任何类型只要实现了接口中定义的所有方法，就被认为是该接口类型的实现；
* 所有类型均是空接口的实现；

## 三、内置函数
### 1, append
* `func append(slice []Type, elems ...Type) []Type`；
* append 内置函数将元素追加到切片的末尾；
* 如果切片有足够的容量，则直接将新元素添加到底层数组；
* 如果没有，将触发扩容分配一个新的底层数组，此时指向数组的指针指会发生改变，append 返回更新后的切片；

### 2, copy
* `func copy(dst, src []Type) int`；
* copy 内置函数将元素从源切片复制到目标切片中；
* 作为特殊情况，它还会将字节从字符串复制到字节切片；
* 源和目标可能重叠，可能会出现意想不到的情况；
* copy 返回复制的元素数，即 len（src） 和 len（dst） 的最小值；

### 3, delete
* `delete(m map[Type]Type1, key Type)`；
* delete 内置函数从映射中删除具有指定键 `m[key]` 的元素。如果 `m` 为 `nil` 或没有此类元素，则 delete 为空操作。
### 4, len
* `func len(v Type) int`；
* len 内置函数根据其类型返回 v 的长度：
  * 数组或数组指针：v 中的元素数量；
  * slice 或 map：返回 v 中元素数量，如果 v 为 nil，则 len（v） 为零；
  * string：v 中的字节数；
  * channel：通道缓冲区中排队（未读）的元素数，如果 v 为 nil，则 len（v） 为零。

### 5, cap
* `func cap(v Type) int`；
* cap 内置函数根据其类型返回 v 的容量：
  * 数组或数组指针：v 中的元素数量；（与 len（v） 相同）；
  * slice：可以达到的最大长度，如果 v 为 nil，则 cap（v） 为零；
  * channel：通道缓冲区容量，如果 v 为 nil，则 cap（v） 为零；
### 6, make
* ``；
### 7, new
* ``；
### 8, close
* ``；
### 9, panic
* ``；
### 10, recover
* ``；
### 11, print
* ``；
### 12, println
* ``；
### 13, complex
* ``；
### 14, real
* ``；
### 15, imag
* ``；
## 四、同步原语

## 五、

