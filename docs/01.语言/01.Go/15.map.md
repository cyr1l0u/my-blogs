---
title: go 容器之 map
date: 2024-01-13 14:49:07
permalink: /pages/93395a/
categories:
  - 语言
  - Go
tags:
  - 
author: 
  name: erlangtui
  link: https://github.com/erlangtui
---

* <span style="color: red;">基本的实现逻辑</span>
::: tip
本文代码基于 go1.17.13，src/runtime/chan.go
:::
## 一、简述
* ……

## 二、基本原理
### 1，存储逻辑
* map 是一种无序的键值对集合，也被称为哈希表或字典，基本原理是使用哈希函数将键映射到存储桶中，在存储桶中保存键值对，以实现 O(1) 复杂度的查找；
* 哈希函数在哈希种子的基础上将键的内容映射到一个固定范围的整数值，即哈希值，对存储桶数组长度求余后找到对应的桶；
* 哈希值的低位用于获取 key 对应的桶，哈希值的高位用于快速判断 key 是否在该桶中；
* **存储桶数组是内存上多个连续的桶的集合，每个桶都存储具有相同哈希值的键值对、顶部哈希值和该桶的溢出桶指针，存储桶数组长度会根据负载因子和溢出桶数量动态调整**；
* 哈希冲突时，map 采用的是**链接地址法的方式解决哈希冲突**的，哈希值相同的键值对放入同一个存储桶中，存储桶满了之后会在其后链接新的溢出桶存放其他相同哈希值的键值对；

### 2，扩容条件
* map 在**溢出桶数量过多（近似大于存储桶的数量）或是负载因子过大**时会执行扩容逻辑；
* 负载因子（loadFactor）即平均每个存储桶存储的键值对数量，默认情况下一个存储桶最多存储 8 个键值对；
* 如果负载因子太大，则产生很多溢流桶；负载因子太小，会浪费存储空间；

| loadFactor | %overflow | bytes/entry | hitprobe | missprobe |
| :--------: | :-------: | :---------: | :------: | :-------: |
|    4.00    |   2.13    |    20.77    |   3.00   |   4.00    |
|    4.50    |   4.05    |    17.30    |   3.25   |   4.50    |
|    5.00    |   6.85    |    14.77    |   3.50   |   5.00    |
|    5.50    |   10.55   |    12.94    |   3.75   |   5.50    |
|    6.00    |   15.27   |    11.67    |   4.00   |   6.00    |
|    6.50    |   20.90   |    10.79    |   4.25   |   6.50    |
|    7.00    |   27.14   |    10.15    |   4.50   |   7.00    |
|    7.50    |   34.03   |    9.73     |   4.75   |   7.50    |
|    8.00    |   41.10   |    9.40     |   5.00   |   8.00    |

* 以上是不同负载的一些统计数据：
  - %overflow：具有溢出桶的存储桶百分比；
  - bytes/entry：每个键值对使用的开销字节数；
  - hitprobe：查找当前 key 需要检查的条目数；
  - missprobe：查找缺失 key 需要检查的条目数；
  - 此数据适用于最大负载的表，即在表扩容之前，典型的表的负载会稍少一些；

## 三、基本用法
### 1，应用场景

### 2，注意事项

### 3，简单示例

## 四、源码解读
### 1，默认值
::: details
```go
const (
	// 每个桶能够存储的最多键值对数
	bucketCntBits = 3
	bucketCnt     = 1 << bucketCntBits

	// 平均每个桶的最大负载因子，loadFactorNum/loadFactorDen
	loadFactorNum = 13
	loadFactorDen = 2

	maxKeySize  = 128 // 保证键值内联的最大尺寸
	maxElemSize = 128

	// bmap 经过编译后会扩充 keys、values 等字段，keys 是紧跟在 tophash 字段之后的
	// 通过这种方式能够计算出 keys 相对于 bmap 起始地址的偏移，也是 tophash 的大小
	dataOffset = unsafe.Offsetof(struct {
		b bmap
		v int64
	}{}.v)

	// 可能的 tophash 值
	emptyRest      = 0 // 此单元格为空，并且在较高的索引或溢出处不再有非空单元格
	emptyOne       = 1 // 此单元格为空，其他单元格未知
	evacuatedX     = 2 // 键值是有效的，已迁移到新桶的前半部分
	evacuatedY     = 3 // 键值是有效的，入口已迁移到新桶的后半部分
	evacuatedEmpty = 4 // 单元格为空，数据已经迁移走了
	minTopHash     = 5 // 正常填充单元格的最小顶部哈希

	// 标志位
	iterator     = 1 // 可能存在使用存储桶的迭代器
	oldIterator  = 2 // 可能存在使用旧的存储桶的迭代器
	hashWriting  = 4 // 有其他 goroutine 正在写该map
	sameSizeGrow = 8 // 当前 map 正在进行等量扩容

	// 用于迭代器检查的哨兵存储桶 ID
	noCheck = 1<<(8*sys.PtrSize) - 1
)
```
:::
* **每个桶最多存储 8 个键值对**，当前桶存满了时依次放入后续的溢出桶；
* **平均每个桶的最大负载因子为 6.5，超过此值后 map 开始翻倍扩容**；
* 保证键值内联的最大尺寸为 128 字节，当键或值的大小小于等于此限制时，直接保存在 map 结构体中；如果键或值的大小超过了这个限制，会为每个元素单独分配内存，键和值将被存储在堆上；这种设计是**为了在性能和内存利用之间取得平衡，将较小的键和值直接保存在 map 结构体中可以提高访问速度，因为无需通过指针间接访问；对于较大的键和值，为其分配单独的内存可以节省内存空间，并避免 map 结构体变得过大**；
* 哈希值标志用于在每个桶的顶部哈希值数组中标志当前哈希值对应的单元格状态，为空或是已经迁移；
* 标志位用于标志当前 map 的状态，被迭代、写数据或扩容等；

### 2，hmap
```go
type hmap struct {
	count      int            // map 元素个数，必须在第一位，由内置函数 len() 调用
	flags      uint8          // map 的标志，是否处于迭代器、写、扩容等状态
	B          uint8          // 存储桶的数量的对数值，桶数等于 2^B，如果在搬迁过程中则指的是新存储桶数量的对数
	noverflow  uint16         // 溢出桶的大概数量，为了保持hmap较小，noverflow 是一个uint16。
	hash0      uint32         // 哈希种子
	buckets    unsafe.Pointer // 指向存储桶数组的指针，多个桶在内存上是连续的，当 count 为 0 时，为 nil
	oldbuckets unsafe.Pointer // 在扩容时指向旧桶数组的指针，仅在扩容时不为空，扩容结束后置为空，以此判断是否处于扩容状态
	nevacuate  uintptr        // 迁移进度计数器（小于此值的索引对应的桶已清空）

	extra *mapextra // 额外字段，主要存储溢出桶等信息
}

// mapextra 保存并非所有 map 都存在的字段
type mapextra struct {
	overflow     *[]*bmap // 存储所有存储桶 hmap.buckets 的溢出桶指针
	oldoverflow  *[]*bmap // 存储所有旧存储桶 hmap.oldbuckets 的溢出桶指针，扩容时才有
	nextOverflow *bmap    // 指向首个可用溢出桶的指针，在创建存储桶数组时，会额外创建多个溢出桶，这些溢出桶在内存上也是连续的
}
```
* hmap 存储了 map 对象的基本信息，包括元素个数、存储桶数量、溢出桶数量、存储桶数组指针、溢出桶信息等；
* 其中，**等量扩容时 buckets 数组与 oldbuckets 数组长度相等；翻倍扩容时，buckets 数组是 oldbuckets 数组长度的两倍**；
* mapextra 存储了 map 的溢出桶相关信息，如果 key 和 elem 都不包含指针并且是内联的，那么将存储桶类型标记为不包含指针，可以避免 gc 扫描此类 map；
* 内联存储：即 key 和 value 直接存储在哈希表的结构中，而不是存储在堆上；

::: details
```go
// 为桶 b 创建溢出桶对象
func (h *hmap) newoverflow(t *maptype, b *bmap) *bmap {
	var ovf *bmap
	if h.extra != nil && h.extra.nextOverflow != nil {
		// 已经在 makeBucketArray 函数中预分配了下一个溢出桶对象，直接使用
		ovf = h.extra.nextOverflow
		if ovf.overflow(t) == nil {
			// 详见 makeBucketArray 函数 last.setoverflow(t, (*bmap)(buckets)) 位置处
			// 还未到达最后一个预分配的溢出桶，让下一个溢出桶指针 nextOverflow 往后移
			h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), uintptr(t.bucketsize)))
		} else {
			// 已经是最后一个预分配的溢出存储桶，重置此溢出桶上的溢出指针为 nil，并将下一个溢出桶指针 nextOverflow 也置为 nil
			ovf.setoverflow(t, nil)
			h.extra.nextOverflow = nil
		}
	} else {
		// 没有可用的预先分配的溢出桶, 直接创建一个新桶
		ovf = (*bmap)(newobject(t.bucket))
	}
	h.incrnoverflow() // 增加溢出桶计数
	if t.bucket.ptrdata == 0 {
		h.createOverflow()
		*h.extra.overflow = append(*h.extra.overflow, ovf) // 将该溢出桶指针添加到溢出桶数组
	}
	b.setoverflow(t, ovf) // 将当前溢出桶地址存储到 b 的溢出桶指针上，即形成溢出桶链表
	return ovf
}

// incrnoverflow 递增溢出存储桶的计数
func (h *hmap) incrnoverflow() {
	// 如果溢出存储桶与存储桶一样多，将触发相同大小的 map 扩容
	if h.B < 16 {
		h.noverflow++
		return
	}
	// 当存储桶的数量达到 1<<15-1 时，溢出桶的数量大概等于存储桶，以 1/(1<<(h.B-15)) 的概率增加溢出桶
	mask := uint32(1)<<(h.B-15) - 1
	// 举例: if h.B == 18, then mask == 7, and fastrand & 7 == 0 概率为 1/8.
	if fastrand()&mask == 0 {
		h.noverflow++
	}
}

// 没有溢出桶数组时，则创建溢出桶数组
func (h *hmap) createOverflow() {
	if h.extra == nil {
		h.extra = new(mapextra)
	}
	if h.extra.overflow == nil {
		h.extra.overflow = new([]*bmap)
	}
}

// 是否正在扩容，等量扩容或翻倍扩容，即旧溢出桶数组指针 oldbuckets 不为空
func (h *hmap) growing() bool {
	return h.oldbuckets != nil
}

// 当前扩容是否是等量扩容
func (h *hmap) sameSizeGrow() bool {
	return h.flags&sameSizeGrow != 0 // 即 flags 的第 4 位不为 0
}

// 当前 map 扩容之前的存储桶数
func (h *hmap) noldbuckets() uintptr {
	// B 为当前存储桶数量对数值，如果是等量扩容则与旧的相等，如果是翻倍扩容则比旧的大 1
	oldB := h.B
	if !h.sameSizeGrow() {
		oldB-- // 对数值减一，桶数量减半
	}
	return bucketShift(oldB)
}

// 返回旧存储桶数量生成的掩码值
func (h *hmap) oldbucketmask() uintptr {
	return h.noldbuckets() - 1
}
```
:::
* `newoverflow`方法为某个桶创建溢出桶，**如果在创建存储桶的时候同时创建了一些溢出桶，在 makeBucketArray 函数中预分配了下一个溢出桶对象，且这些溢出桶还没有使用完则直接使用**；否则，直接创建一个新的溢出桶，并将该桶添的指针添加到溢出桶指针数组中；
* `incrnoverflow`方法递增溢出存储桶的计数，当存储桶很少时，递增操作直接执行，noverflow 是一个精确的计数；当存储桶很多时，递增操作以一定的概率执行，noverflow 是一个近似计数；
* `growing`方法判断 map 是否正在扩容，等量扩容或翻倍扩容，即旧存储桶数组指针 oldbuckets 不为空；
* `sameSizeGrow`方法通过判断 flags 的第 4 位是否为 0，表示当前扩容是否为等量扩容；
* `noldbuckets`方法计算 map 旧存储桶的数量，如果 map 是翻倍扩容，那么旧存储桶数量是现在的一半，如果是等量扩容，那么与现在的相等；
* `oldbucketmask`方法计算 map 旧存储桶数量生成的**掩码值，方便进行位与运算，以求出 key 的哈希值对旧存储桶数量的余数，来确定桶的索引**；eg：当 B 为 5 时，旧 B 为 4，旧存储桶数量为 16，生成的掩码值为 0b1111，如果哈希值为 0b1101001010，直接位与运算得到 0b1010，即等于 6，桶的索引号为 6；

::: details
```go
// bucketShift 返回 2^b，针对代码生成进行了优化
func bucketShift(b uint8) uintptr {
	return uintptr(1) << (b & (sys.PtrSize*8 - 1))
}

// bucketMask 返回 2^b-1，即对应的掩码值，针对代码生成进行了优化
func bucketMask(b uint8) uintptr {
	return bucketShift(b) - 1
}

// tophash 计算 hash 的顶部 8 位哈希值
func tophash(hash uintptr) uint8 {
	top := uint8(hash >> (sys.PtrSize*8 - 8))
	if top < minTopHash {
		top += minTopHash
	}
	return top
}

// isEmpty 报告给定的 tophash 数组元素是否为空
func isEmpty(x uint8) bool {
	return x <= emptyOne
}
```
:::

### 3，bmap
```go
// map 的桶
type bmap struct {
    // tophash 存储此存储桶中每个键的哈希值顶部 8 字节
    // 如果 tophash[0] < minTopHash，则 tophash[0] 是存储桶迁移状态
	tophash [bucketCnt]uint8
}
```
* `bmap`表示桶的结构，实际编译时会将 bmap 编译成以下结构：
```go
type bmap struct {
	tophash  [bucketCnt]uint8     // 顶部哈希值数组
	keys     [bucketCnt]keytype   // key 数组
	values   [bucketCnt]valuetype // values 数组
	pad      uintptr              // 填充字段
	overflow uintptr              // 溢出桶指针
}
// 获取当前桶的溢出桶指针
func (b *bmap) overflow(t *maptype) *bmap {
	// 指针运算，桶指针往后移动一个桶大小的距离，再往前移动一个指针的距离，就是其溢出桶指针的地址
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
}
// 将溢出桶的地址存储到当前桶的溢出桶指针上
func (b *bmap) setoverflow(t *maptype, ovf *bmap) {
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
}
// 获取当前桶的 keys 地址
func (b *bmap) keys() unsafe.Pointer {
	// 桶地址往后偏移 dataOffset
	return add(unsafe.Pointer(b), dataOffset)
}
// 通过顶部哈希值判断某个桶是否正在迁移中
func evacuated(b *bmap) bool {
	h := b.tophash[0]
	return h > emptyOne && h < minTopHash
}
```
* `tophash`表示顶部哈希值数组，存储了该桶中每个 key 的顶部哈希值，通过顶部哈希值可以知道对应 key 的状态（已迁移、为空等）；
* `keys`表示 key 数组，存储了该桶中所有的 key；`values`表示 value 数组，存储了该桶中所有的 value；
* 实际存储过程中，将所有的键连续存储在一起，将所有的值连续存储在一起，能够一定程度上避免 键值/键值 存储方式的所需要的内存对齐；比如`map[int64]byte`，如果以 键值/键值 方式存储，每个键值对需要填充7字节以对齐内存；
* `overflow`是溢出桶指针，指向该桶的溢出桶；





> **参考文章**<br>
> [1] [二郎腿的博客](https://erlangtui.top)<br>
