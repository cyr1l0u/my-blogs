---
title: go 容器之 map
date: 2024-01-13 14:49:07
permalink: /pages/93395a/
categories:
  - 语言
  - Go
tags:
  - 
author: 
  name: erlangtui
  link: https://github.com/erlangtui
---

* <span style="color: red;">基本的实现逻辑</span>
::: tip
本文代码基于 go1.17.13，src/runtime/chan.go
:::
## 一、简述
* ……

## 二、基本原理
### 1，存储逻辑
* map 是一种无序的键值对集合，也被称为哈希表或字典，基本原理是使用哈希函数将键映射到存储桶中，在存储桶中保存键值对，以实现 O(1) 复杂度的查找；
* 哈希函数在哈希种子的基础上将键的内容映射到一个固定范围的整数值，即哈希值，对存储桶数组长度求余后找到对应的桶；
* 哈希值的低位用于获取 key 对应的桶，哈希值的高位用于快速判断 key 是否在该桶中；
* **存储桶数组是内存上多个连续的桶的集合，每个桶都存储具有相同哈希值的键值对、顶部哈希值和该桶的溢出桶指针，存储桶数组长度会根据负载因子和溢出桶数量动态调整**；
* 哈希冲突时，map 采用的是**链接地址法的方式解决哈希冲突**的，哈希值相同的键值对放入同一个存储桶中，存储桶满了之后会在其后链接新的溢出桶存放其他相同哈希值的键值对；

### 2，扩容条件
* map 在**溢出桶数量过多（近似大于存储桶的数量）或是负载因子过大**时会执行扩容逻辑；
* 负载因子（loadFactor）即平均每个存储桶存储的键值对数量，默认情况下一个存储桶最多存储 8 个键值对；
* 如果负载因子太大，则产生很多溢流桶；负载因子太小，会浪费存储空间；

| loadFactor | %overflow | bytes/entry | hitprobe | missprobe |
| :--------: | :-------: | :---------: | :------: | :-------: |
|    4.00    |   2.13    |    20.77    |   3.00   |   4.00    |
|    4.50    |   4.05    |    17.30    |   3.25   |   4.50    |
|    5.00    |   6.85    |    14.77    |   3.50   |   5.00    |
|    5.50    |   10.55   |    12.94    |   3.75   |   5.50    |
|    6.00    |   15.27   |    11.67    |   4.00   |   6.00    |
|    6.50    |   20.90   |    10.79    |   4.25   |   6.50    |
|    7.00    |   27.14   |    10.15    |   4.50   |   7.00    |
|    7.50    |   34.03   |    9.73     |   4.75   |   7.50    |
|    8.00    |   41.10   |    9.40     |   5.00   |   8.00    |

* 以上是不同负载的一些统计数据：
  - %overflow：具有溢出桶的存储桶百分比；
  - bytes/entry：每个键值对使用的开销字节数；
  - hitprobe：查找当前 key 需要检查的条目数；
  - missprobe：查找缺失 key 需要检查的条目数；
  - 此数据适用于最大负载的表，即在表扩容之前，典型的表的负载会稍少一些；

## 三、基本用法
### 1，应用场景

### 2，注意事项

### 3，简单示例

## 四、源码解读
### 1，默认值
::: details
```go
const (
	// 每个桶能够存储的最多键值对数
	bucketCntBits = 3
	bucketCnt     = 1 << bucketCntBits

	// 平均每个桶的最大负载因子，loadFactorNum/loadFactorDen
	loadFactorNum = 13
	loadFactorDen = 2

	maxKeySize  = 128 // 保证键值内联的最大尺寸
	maxElemSize = 128

	// bmap 经过编译后会扩充 keys、values 等字段，keys 是紧跟在 tophash 字段之后的
	// 通过这种方式能够计算出 keys 相对于 bmap 起始地址的偏移，也是 tophash 的大小
	dataOffset = unsafe.Offsetof(struct {
		b bmap
		v int64
	}{}.v)

	// 可能的 tophash 值
	emptyRest      = 0 // 此单元格为空，并且在较高的索引或溢出处不再有非空单元格
	emptyOne       = 1 // 此单元格为空，其他单元格未知
	evacuatedX     = 2 // 键值是有效的，已迁移到新桶的前半部分
	evacuatedY     = 3 // 键值是有效的，入口已迁移到新桶的后半部分
	evacuatedEmpty = 4 // 单元格为空，数据已经迁移走了
	minTopHash     = 5 // 正常填充单元格的最小顶部哈希

	// 标志位
	iterator     = 1 // 可能存在使用存储桶的迭代器
	oldIterator  = 2 // 可能存在使用旧的存储桶的迭代器
	hashWriting  = 4 // 有其他 goroutine 正在写该map
	sameSizeGrow = 8 // 当前 map 正在进行等量扩容

	// 用于迭代器检查的哨兵存储桶 ID
	noCheck = 1<<(8*sys.PtrSize) - 1
)
```
:::
* **每个桶最多存储 8 个键值对**，当前桶存满了时依次放入后续的溢出桶；
* **平均每个桶的最大负载因子为 6.5，超过此值后 map 开始翻倍扩容**；
* 保证键值内联的最大尺寸为 128 字节，当键或值的大小小于等于此限制时，直接保存在 map 结构体中；如果键或值的大小超过了这个限制，会为每个元素单独分配内存，键和值将被存储在堆上；这种设计是**为了在性能和内存利用之间取得平衡，将较小的键和值直接保存在 map 结构体中可以提高访问速度，因为无需通过指针间接访问；对于较大的键和值，为其分配单独的内存可以节省内存空间，并避免 map 结构体变得过大**；
* 哈希值标志用于在每个桶的顶部哈希值数组中标志当前哈希值对应的单元格状态，为空或是已经迁移；
* 标志位用于标志当前 map 的状态，被迭代、写数据或扩容等；

### 2，hmap
```go
type hmap struct {
	count      int            // map 元素个数，必须在第一位，由内置函数 len() 调用
	flags      uint8          // map 的标志，是否处于迭代器、写、扩容等状态
	B          uint8          // 存储桶的数量的对数值，桶数等于 2^B，如果在搬迁过程中则指的是新存储桶数量的对数
	noverflow  uint16         // 溢出桶的大概数量，为了保持hmap较小，noverflow 是一个uint16。
	hash0      uint32         // 哈希种子
	buckets    unsafe.Pointer // 指向存储桶数组的指针，多个桶在内存上是连续的，当 count 为 0 时，为 nil
	oldbuckets unsafe.Pointer // 在扩容时指向旧桶数组的指针，仅在扩容时不为空，扩容结束后置为空，以此判断是否处于扩容状态
	nevacuate  uintptr        // 迁移进度计数器（小于此值的索引对应的桶已清空）

	extra *mapextra // 额外字段，主要存储溢出桶等信息
}

// mapextra 保存并非所有 map 都存在的字段
type mapextra struct {
	overflow     *[]*bmap // 存储所有存储桶 hmap.buckets 的溢出桶指针
	oldoverflow  *[]*bmap // 存储所有旧存储桶 hmap.oldbuckets 的溢出桶指针，扩容时才有
	nextOverflow *bmap    // 指向首个可用溢出桶的指针，在创建存储桶数组时，会额外创建多个溢出桶，这些溢出桶在内存上也是连续的
}
```
* hmap 存储了 map 对象的基本信息，包括元素个数、存储桶数量、溢出桶数量、存储桶数组指针、溢出桶信息等；
* 其中，**等量扩容时 buckets 数组与 oldbuckets 数组长度相等；翻倍扩容时，buckets 数组是 oldbuckets 数组长度的两倍**；
* mapextra 存储了 map 的溢出桶相关信息，如果 key 和 elem 都不包含指针并且是内联的，那么将存储桶类型标记为不包含指针，可以避免 gc 扫描此类 map；
* 内联存储：即 key 和 value 直接存储在哈希表的结构中，而不是存储在堆上；

::: details
```go
// 为桶 b 创建溢出桶对象，并返回该溢出桶指针
func (h *hmap) newoverflow(t *maptype, b *bmap) *bmap {
	var ovf *bmap
	if h.extra != nil && h.extra.nextOverflow != nil {
		// 已经在 makeBucketArray 函数中预分配了下一个溢出桶对象，直接使用
		ovf = h.extra.nextOverflow
		if ovf.overflow(t) == nil {
			// 详见 makeBucketArray 函数 last.setoverflow(t, (*bmap)(buckets)) 位置处
			// 还未到达最后一个预分配的溢出桶，让下一个溢出桶指针 nextOverflow 往后移
			h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), uintptr(t.bucketsize)))
		} else {
			// 已经是最后一个预分配的溢出存储桶，重置此溢出桶上的溢出指针为 nil，并将下一个溢出桶指针 nextOverflow 也置为 nil
			ovf.setoverflow(t, nil)
			h.extra.nextOverflow = nil
		}
	} else {
		// 没有可用的预先分配的溢出桶, 直接创建一个新桶
		ovf = (*bmap)(newobject(t.bucket))
	}
	h.incrnoverflow() // 增加溢出桶计数
	if t.bucket.ptrdata == 0 {
		h.createOverflow()
		*h.extra.overflow = append(*h.extra.overflow, ovf) // 将该溢出桶指针添加到溢出桶数组
	}
	b.setoverflow(t, ovf) // 将当前溢出桶地址存储到 b 的溢出桶指针上，即形成溢出桶链表
	return ovf
}

// incrnoverflow 递增溢出存储桶的计数
func (h *hmap) incrnoverflow() {
	// 如果溢出存储桶与存储桶一样多，将触发相同大小的 map 扩容
	if h.B < 16 {
		h.noverflow++
		return
	}
	// 当存储桶的数量达到 1<<15-1 时，溢出桶的数量大概等于存储桶，以 1/(1<<(h.B-15)) 的概率增加溢出桶
	mask := uint32(1)<<(h.B-15) - 1
	// 举例: if h.B == 18, then mask == 7, and fastrand & 7 == 0 概率为 1/8.
	if fastrand()&mask == 0 {
		h.noverflow++
	}
}

// 没有溢出桶数组时，则创建溢出桶数组
func (h *hmap) createOverflow() {
	if h.extra == nil {
		h.extra = new(mapextra)
	}
	if h.extra.overflow == nil {
		h.extra.overflow = new([]*bmap)
	}
}

// 是否正在扩容，等量扩容或翻倍扩容，即旧溢出桶数组指针 oldbuckets 不为空
func (h *hmap) growing() bool {
	return h.oldbuckets != nil
}

// 当前扩容是否是等量扩容
func (h *hmap) sameSizeGrow() bool {
	return h.flags&sameSizeGrow != 0 // 即 flags 的第 4 位不为 0
}

// 当前 map 扩容之前的存储桶数
func (h *hmap) noldbuckets() uintptr {
	// B 为当前存储桶数量对数值，如果是等量扩容则与旧的相等，如果是翻倍扩容则比旧的大 1
	oldB := h.B
	if !h.sameSizeGrow() {
		oldB-- // 对数值减一，桶数量减半
	}
	return bucketShift(oldB)
}

// 返回旧存储桶数量生成的掩码值
func (h *hmap) oldbucketmask() uintptr {
	return h.noldbuckets() - 1
}
```
:::
* `newoverflow`方法为某个桶创建溢出桶，**如果在创建存储桶的时候同时创建了一些溢出桶，在 makeBucketArray 函数中预分配了下一个溢出桶对象，且这些溢出桶还没有使用完则直接使用**；否则，直接创建一个新的溢出桶，并将该桶添的指针添加到溢出桶指针数组中；
* `incrnoverflow`方法递增溢出存储桶的计数，当存储桶很少时，递增操作直接执行，noverflow 是一个精确的计数；当存储桶很多时，递增操作以一定的概率执行，noverflow 是一个近似计数；
* `growing`方法判断 map 是否正在扩容，等量扩容或翻倍扩容，即旧存储桶数组指针 oldbuckets 不为空；
* `sameSizeGrow`方法通过判断 flags 的第 4 位是否为 0，表示当前扩容是否为等量扩容；
* `noldbuckets`方法计算 map 旧存储桶的数量，如果 map 是翻倍扩容，那么旧存储桶数量是现在的一半，如果是等量扩容，那么与现在的相等；
* `oldbucketmask`方法计算 map 旧存储桶数量生成的**掩码值，方便进行位与运算，以求出 key 的哈希值对旧存储桶数量的余数，来确定桶的索引**；eg：当 B 为 5 时，旧 B 为 4，旧存储桶数量为 16，生成的掩码值为 0b1111，如果哈希值为 0b1101001010，直接位与运算得到 0b1010，即等于 6，桶的索引号为 6；

::: details
```go
// bucketShift 返回 2^b，针对代码生成进行了优化
func bucketShift(b uint8) uintptr {
	return uintptr(1) << (b & (sys.PtrSize*8 - 1))
}

// bucketMask 返回 2^b-1，即对应的掩码值，针对代码生成进行了优化
func bucketMask(b uint8) uintptr {
	return bucketShift(b) - 1
}

// tophash 计算 hash 的顶部 8 位哈希值
func tophash(hash uintptr) uint8 {
	top := uint8(hash >> (sys.PtrSize*8 - 8))
	if top < minTopHash {
		top += minTopHash
	}
	return top
}

// isEmpty 报告给定的 tophash 数组元素是否为空
func isEmpty(x uint8) bool {
	return x <= emptyOne
}
```
:::

### 3，bmap
```go
// map 的桶
type bmap struct {
    // tophash 存储此存储桶中每个键的哈希值顶部 8 字节
    // 如果 tophash[0] < minTopHash，则 tophash[0] 是存储桶迁移状态
	tophash [bucketCnt]uint8
}
```
* `bmap`表示桶的结构，实际编译时会将 bmap 编译成以下结构：
```go
type bmap struct {
	tophash  [bucketCnt]uint8     // 顶部哈希值数组
	keys     [bucketCnt]keytype   // key 数组
	values   [bucketCnt]valuetype // values 数组
	pad      uintptr              // 填充字段
	overflow uintptr              // 溢出桶指针
}
// 获取当前桶的溢出桶指针
func (b *bmap) overflow(t *maptype) *bmap {
	// 指针运算，桶指针往后移动一个桶大小的距离，再往前移动一个指针的距离，就是其溢出桶指针的地址
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
}
// 将溢出桶的地址存储到当前桶的溢出桶指针上
func (b *bmap) setoverflow(t *maptype, ovf *bmap) {
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
}
// 获取当前桶的 keys 地址
func (b *bmap) keys() unsafe.Pointer {
	// 桶地址往后偏移 dataOffset
	return add(unsafe.Pointer(b), dataOffset)
}
// 通过顶部哈希值判断某个桶是否已经迁移完成
func evacuated(b *bmap) bool {
	h := b.tophash[0]
	return h > emptyOne && h < minTopHash
}
```
* `tophash`表示顶部哈希值数组，存储了该桶中每个 key 的顶部哈希值，通过顶部哈希值可以知道对应 key 的状态（已迁移、为空等）；
* `keys`表示 key 数组，存储了该桶中所有的 key；`values`表示 value 数组，存储了该桶中所有的 value；
* 实际存储过程中，将所有的键连续存储在一起，将所有的值连续存储在一起，能够一定程度上避免 键值/键值 存储方式的所需要的内存对齐；比如`map[int64]byte`，如果以 键值/键值 方式存储，每个键值对需要填充7字节以对齐内存；
* `overflow`是溢出桶指针，指向该桶的溢出桶；

### 4，makemap
```go
func makemap_small() *hmap {
	h := new(hmap)
	h.hash0 = fastrand()
	return h
}
```
* `makemap_small` 为 `make(map[k]v)` 和 `make(map[k]v, hint)` 创建 map，前提是在编译时已知 hint 最多为 bucketCnt，并且需要在堆上分配 hmap，即通过 new 创建 *hmap 指针；
* 其桶的创建是在 mapassign 函数中完成的，即在插入数据时惰性创建；

```go
// makemap make(map[k]v, hint) 的实现，如果编译器已经检测到能够在栈上创建 map 或第一个桶，则 h 或 bucket 非空
// 如果 h 非空，则能够直接在 h 上创建 map, 如果 h.buckets 非空，则指向的 bucket 可以用作第一个存储桶
func makemap(t *maptype, hint int, h *hmap) *hmap {
	// 计算需要申请的内存大小，并进行校验
	mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
	if overflow || mem > maxAlloc {
		hint = 0
	}

	// 初始化 hmap
	if h == nil {
		h = new(hmap)
	}
	h.hash0 = fastrand()

	// 确定 B 的值，以保证 2^B 个桶能够装下 hint 个元素，且负载因子在约定范围内
	B := uint8(0)
	for overLoadFactor(hint, B) {
		B++ // 桶的数量翻倍
	}
	h.B = B

	// 分配哈希表，如果 B == 0，则稍后会延迟分配 buckets 字段（在 mapassign 中） 如果 hint 很大，则将此内存归零可能需要一段时间
	if h.B != 0 {
		var nextOverflow *bmap
		// 获取存储存储桶数组指针和下一个溢出桶指针
		h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
		if nextOverflow != nil {
			h.extra = new(mapextra)
			h.extra.nextOverflow = nextOverflow
		}
	}

	return h
}
```
* `makemap` 用于创建能够存储 hint 个键值对的 map；
* 根据 hint 确定 B 的值，以保证 2^B 个桶能够装下 hint 个元素，且负载因子在约定范围内；
* 如果只需要一个桶，则延迟在 `mapassign` 函数中进行创建；否则，直接通过`makeBucketArray`创建多个桶及一些溢出桶（如果 B 够大）；

```go
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
	base := bucketShift(b)
	nbuckets := base
	// 实际分配桶的数量是 nbuckets，是不小于 base，前 base 个桶依旧为存储桶，base 之后的用作溢出桶
	// 这些桶在内存上是连续的，每个桶的溢出桶指针是 nil，最后一个桶的溢出桶指针记为非 nil，以标记该桶是最后一个溢出桶了

	if b >= 4 { // 对于小 b，溢出桶的可能性不大，默认不创建溢出桶，添加该条件能够避免计算的开销
		nbuckets += bucketShift(b - 4) // 额外申请 1/16 存储桶数量的桶，2^b+2^b/16
		sz := t.bucket.size * nbuckets // nbuckets 个桶所需的内存大小
		up := roundupsize(sz)          // 将其对齐到最近的较大的2的幂次方数值
		if up != sz {                  // 如果对齐后的值与原始值不相等，则用对齐后的内存大小计算实际的桶数 nbuckets
			nbuckets = up / t.bucket.size
		}
	}

	if dirtyalloc == nil {
		// 直接分配一个新的底层数组
		buckets = newarray(t.bucket, int(nbuckets))
	} else {
		// 复用 dirtyalloc 指向的原数组，并将该数组内存清空，t 和 b 与申请 dirtyalloc 时相同，所以原数组大小是满足条件的
		buckets = dirtyalloc
		size := t.bucket.size * nbuckets
		if t.bucket.ptrdata != 0 {
			// 桶中的元素类型带有指针时，数组内存的清空方式
			memclrHasPointers(buckets, size)
		} else {
			// 桶中的元素类型没有指针时，数组内存的清空方式
			memclrNoHeapPointers(buckets, size)
		}
	}

	if base != nbuckets {
		// 预先分配了一些溢出桶，为了将跟踪这些溢出桶的开销降至最低，我们使用这样的约定:
		// 如果预分配的溢出桶的溢出指针为 nil，则通过向后移动指针可以获得更多可用的溢出桶；
		// 对于最后一个桶的溢出桶的溢出指针，需要一个安全的非空指针，直接用 buckets，以区分该桶为最后一个溢出桶；

		// 前 0 ~ base-1 个桶为存储桶，base ~ nbuckets-1 个桶为溢出桶，这些桶在内存上连续
		// 通过调用add函数计算下一个溢出桶 nextOverflow 的地址，并将其转换为*bmap类型的指针
		nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize)))
		// 通过调用add函数计算出最后一个桶的地址，并将其转换为*bmap类型的指针
		last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize)))
		// 将 buckets 强制转换为*bmap类型的指针，并赋值给最后一个桶的溢出指针
		// 即第 nbuckets-1 个桶的溢出桶指针记为非 nil，以标记该桶是最后一个桶了，会在 newoverflow 函数中用到
		last.setoverflow(t, (*bmap)(buckets))
	}
	return buckets, nextOverflow
}
```
* makeBucketArray 用于创建一个存储桶数组，如果键值对较多的话，会额外创建一些桶作为溢出桶，并返回该数组的地址和第一个溢出桶地址(存储在mapextra结构体的nextOverflow字段)；这些桶在内存上是连续的，取前部分为存储桶，后部分为溢出桶，最后一个溢出桶的溢出指针不为空，以表示该桶是最后一个桶，方便在以指针运算的方式遍历溢出桶时能够获取结束标志；
* 2^b 是需要分配存储桶的最小数量，当 b<4 时，溢出的可能性不大，不会创建溢出桶；当 b>=4 时，会总共申请 2^b+2^b/16 个桶，由于内存申请策略会向上对齐，实际申请的内存可能足以放下更多的桶；此时，取前 2^b 个桶作为存储桶，后面的为溢出桶，buckets 指向存储桶数组首位地址，nextOverflow 指向首位溢出桶；
* dirtyalloc 应该是 nil 或指向之前由 makeBucketArray 以相同 t 和 b 参数分配的存储桶数组；如果 dirtyalloc 是 nil 则会重新申请内存分配一个新的存储桶数组，否则 dirtyalloc 指向的数组将会被清理掉并被重新被复用为存储桶数组


### 5，mapaccess1
```go
func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
	if h == nil || h.count == 0 {
		if t.hashMightPanic() { // hash 函数是否可能引发 panic
			t.hasher(key, 0) // see issue 23734
		}
		return unsafe.Pointer(&zeroVal[0])
	}
	if h.flags&hashWriting != 0 {
		// 并发读写，抛出错误
		throw("concurrent map read and map write")
	}
	hash := t.hasher(key, uintptr(h.hash0)) // 计算 key 的哈希值
	m := bucketMask(h.B)                    // 返回桶的数量减一
	// hash&m 计算哈希值对桶数量的余数，即哈希值的后 B 位对应的值
	b := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize))) // 计算该 key 经过哈希后应该落入的桶的地址
	if c := h.oldbuckets; c != nil {
		//  正在扩容中
		if !h.sameSizeGrow() {
			// 如果是翻倍扩容，旧容量的大小应该是现在的一半，即需要计算哈希值的后 B-1 位
			m >>= 1
		}
		oldb := (*bmap)(add(c, (hash&m)*uintptr(t.bucketsize)))
		if !evacuated(oldb) {
			// 当前旧桶没有迁移走，则直接选择旧桶
			b = oldb
		}
	}
	top := tophash(hash) // 计算顶部 8 位哈希值
bucketloop:
	for ; b != nil; b = b.overflow(t) {
		// 从桶开始沿着溢出桶依次遍历
		for i := uintptr(0); i < bucketCnt; i++ {
			// 对每个桶依次遍历
			if b.tophash[i] != top {
				// 在桶中依次比较顶部哈希值，如果顶部哈希值不相等，则跳过当前值
				if b.tophash[i] == emptyRest {
					// 如果顶部哈希值为 emptyRest，则说明整个桶都为空，直接跳出当前桶
					break bucketloop
				}
				continue
			}
			// 顶部哈希值相等，根据顶部哈希值索引 i 计算该哈希值对应的 key 的地址
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
			if t.indirectkey() {
				// 如果是存储 key 的指针而不是 key 本身，则解引用
				k = *((*unsafe.Pointer)(k))
			}
			if t.key.equal(key, k) {
				// 如果桶中存储的 key 与待查找的 key 相等，则计算该 key 对应的值的地址
				e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
				if t.indirectelem() {
					// 如果存储 elem 的指针而不是 elem 本身，则解引用
					e = *((*unsafe.Pointer)(e))
				}
				// 找到 key 对应的 elem，直接返回
				return e
			}
			// 如果桶中存储的 key 与待查找的 key 相等，继续查找下一个元素
		}
		// 继续查找下一个桶，直至溢出桶结束
	}
	// 在 key 哈希值对应的桶及其溢出桶都没有找到，则直接返回零值指针
	return unsafe.Pointer(&zeroVal[0])
}
```
* mapaccess1 返回指向 h[key] 的指针，从不返回 nil，相反，如果键不在 map 中，它将返回对 elem 类型的零值对象的引用，返回的指针可能会使整个 map 保持活动状态，因此不要长时间保留它；
* 如果 map 为空或是没有元素，直接返回指向零值的指针，如果有其他 goroutine 正在写，则直接抛出并发读写错误，不可恢复；
* 具体查找逻辑：
	* 计算 key 对应的哈希值，根据桶数组的对数值 B 计算出该 key 对应的存储桶；
	* 如果 map 正在扩容中，并且是翻倍扩容，那么该 key 对应的旧存储桶序号可能与新存储桶不一致，需要根据旧桶数组的对数值 B' 重新计算 key 对应的旧存储桶；
	* 如果该旧存储桶已经迁移完成了，则直接在新存储桶里面查找，否则直接在旧存储桶中查找；
	* 通过 key 的哈希值确定存储桶后，依次遍历存储桶及其溢出桶，遍历每个桶时，依次与每个顶部哈希值比较，顶部哈希值相等时，再去与 key 进行比较，key 相等时，直接获取其对应的 elem 的指针，存储桶及其溢出桶都遍历完还没有找到时，则直接返回指向零值的指针；

::: details
```go
func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) {
	if h == nil || h.count == 0 {
		if t.hashMightPanic() {
			t.hasher(key, 0) // see issue 23734
		}
		return unsafe.Pointer(&zeroVal[0]), false
	}
	if h.flags&hashWriting != 0 {
		throw("concurrent map read and map write")
	}
	hash := t.hasher(key, uintptr(h.hash0))
	m := bucketMask(h.B)
	b := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
	if c := h.oldbuckets; c != nil {
		if !h.sameSizeGrow() {
			// There used to be half as many buckets; mask down one more power of two.
			m >>= 1
		}
		oldb := (*bmap)(add(c, (hash&m)*uintptr(t.bucketsize)))
		if !evacuated(oldb) {
			b = oldb
		}
	}
	top := tophash(hash)
bucketloop:
	for ; b != nil; b = b.overflow(t) {
		for i := uintptr(0); i < bucketCnt; i++ {
			if b.tophash[i] != top {
				if b.tophash[i] == emptyRest {
					break bucketloop
				}
				continue
			}
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
			if t.indirectkey() {
				k = *((*unsafe.Pointer)(k))
			}
			if t.key.equal(key, k) {
				e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
				if t.indirectelem() {
					e = *((*unsafe.Pointer)(e))
				}
				return e, true
			}
		}
	}
	return unsafe.Pointer(&zeroVal[0]), false
}

func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer) {
	if h == nil || h.count == 0 {
		return nil, nil
	}
	hash := t.hasher(key, uintptr(h.hash0))
	m := bucketMask(h.B)
	b := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
	if c := h.oldbuckets; c != nil {
		if !h.sameSizeGrow() {
			m >>= 1
		}
		oldb := (*bmap)(add(c, (hash&m)*uintptr(t.bucketsize)))
		if !evacuated(oldb) {
			b = oldb
		}
	}
	top := tophash(hash)
bucketloop:
	for ; b != nil; b = b.overflow(t) {
		for i := uintptr(0); i < bucketCnt; i++ {
			if b.tophash[i] != top {
				if b.tophash[i] == emptyRest {
					break bucketloop
				}
				continue
			}
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
			if t.indirectkey() {
				k = *((*unsafe.Pointer)(k))
			}
			if t.key.equal(key, k) {
				e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
				if t.indirectelem() {
					e = *((*unsafe.Pointer)(e))
				}
				return k, e
			}
		}
	}
	return nil, nil
}
```
:::
* mapaccess2 与 mapaccess1 相比，多返回的一个 bool 值，true 表示取到了真实的值而不是零值，false 表示取到了零值；
* mapaccessK 与 mapaccess1 相比，同时返回了 key 和 elem 的指针，用于 map 迭代器；

### 6，mapassign
```go
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
	if h == nil {
		// map 为 nil，直接 panic，无法向一个 nil 中写数据
		panic(plainError("assignment to entry in nil map"))
	}
	if h.flags&hashWriting != 0 {
		// 并发写抛出错误
		throw("concurrent map writes")
	}
	hash := t.hasher(key, uintptr(h.hash0))

	// 调用 t.hasher 再后设置 hashWriting，因为 t.hasher 可能会 panic，在这种情况下，实际上还没有进行写入
	h.flags ^= hashWriting

	if h.buckets == nil {
		// 如果桶为空，则创建一个新的桶，初始状态为一个桶
		h.buckets = newobject(t.bucket) // newarray(t.bucket, 1)
	}

again:
	bucket := hash & bucketMask(h.B) // 计算该 key 对应的桶的索引号
	if h.growing() {
		// 如果 map 处于扩容过程中，则迁移该桶及其后续未迁移的桶（如果还有的话）
		growWork(t, h, bucket)
	}
	// 直接从存储桶数组 h.buckets 中获取 bucket 索引对应的桶（如果在搬迁，该存储桶数组是新的，h.B 也是新存储桶数组的长度对数）
	b := (*bmap)(add(h.buckets, bucket*uintptr(t.bucketsize)))
	top := tophash(hash)

	var inserti *uint8         // 顶部哈希值数组中空单元格的地址
	var insertk unsafe.Pointer // key 数组中空单元格的地址
	var elem unsafe.Pointer    // elem 数组中空单元格的地址或是 k 对应的 elem 的地址

bucketloop: // 从桶中找到当前 k，或是找到一个空的单元格
	for {
		// 依次遍历存储桶及其溢出桶，在桶中依次遍历每个顶部哈希值、key、elem
		for i := uintptr(0); i < bucketCnt; i++ {
			if b.tophash[i] != top {
				// 顶部哈希值不相等，即不是要找的 k
				if isEmpty(b.tophash[i]) && inserti == nil {
					// 如果当前 b.tophash[i] 为空，且 inserti 为空，则记录当前 i 对应的 key、elem 对应的地址
					// 即 inserti 用于存储第一个为空的顶部哈希值数组单元格的地址
					inserti = &b.tophash[i]
					insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
					elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
				}
				if b.tophash[i] == emptyRest {
					// 如果此单元格为空，并且在较高的索引或溢出处不再有非空单元格，则跳出大循环 bucketloop
					break bucketloop
				}
				// 如果此空单元格之后还有其他的非空单元格，继续往后遍历其他单元格
				continue
			}
			// 顶部哈希值相等，可能是要找到的 k，取 i 对应的位置的 key
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
			if t.indirectkey() {
				// 存储的是指针，解引用
				k = *((*unsafe.Pointer)(k))
			}
			// 判断存储的 key 是否与查找的 k 相等
			if !t.key.equal(key, k) {
				// 不相等，继续往后遍历其他单元格
				continue
			}
			// key 相等，找到了该 key
			if t.needkeyupdate() {
				// 如果需要更新该 key 则直接更新
				typedmemmove(t.key, k, key)
			}
			// 获取该 key 对应的 elem 的地址，跳转到 done
			elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
			goto done
		}
		// 如果在该桶中既没有找到当前 k，也没有找到空的单元格或找到的空单元格后较高的索引或溢出处有非空单元格
		// 则继续往后遍历其他溢出桶
		ovf := b.overflow(t)
		if ovf == nil {
			break
		}
		b = ovf
	}

	// 执行到此处，说明没有找到相等的 key
	// 如果命中了负载因子阈值或是有太多的溢出桶，并且又没有正在扩容，则开始扩容
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
		// 开始扩容，创建存储桶数组和溢出桶数组，并分布切换旧桶数组指针和旧溢出桶数组指针的指向，不做实际搬迁
		hashGrow(t, h)
		// 开始扩容后，存储桶数组地址发生改变，数组长度可能也会发生改变，需要跳转到 again 重新开始查找
		// 并更新存储桶 b 的地址，并迁移数据，如果仍然没有找到，则将 key 写入 map 时能够写入正确的桶
		goto again
	}

	if inserti == nil {
		// 没有找到相等的 key，且 inserti 又为 nil，则说明当前桶及其溢出桶已经满了，直接创建一个新的溢出桶
		newb := h.newoverflow(t, b)
		inserti = &newb.tophash[0]
		insertk = add(unsafe.Pointer(newb), dataOffset)
		elem = add(insertk, bucketCnt*uintptr(t.keysize))
	}

	if t.indirectkey() {
		// 存储的是 key 指针，则从堆上申请内存，并赋值地址
		kmem := newobject(t.key)
		*(*unsafe.Pointer)(insertk) = kmem
		insertk = kmem
	}
	if t.indirectelem() {
		// 存储的是 elem 指针，则从堆上申请内存，并赋值地址
		vmem := newobject(t.elem)
		*(*unsafe.Pointer)(elem) = vmem
	}
	// 执行到此处说明是 map 中新增了元素，记录 key、top，并且 map 中的元素数量加一
	typedmemmove(t.key, insertk, key)
	*inserti = top
	h.count++

done: // 直接跳转到此处说明是找到了已经存储的 key
	if h.flags&hashWriting == 0 {
		// 有其他 goroutine 正在写，抛出错误
		throw("concurrent map writes")
	}
	h.flags &^= hashWriting // 清除写标志
	if t.indirectelem() {
		elem = *((*unsafe.Pointer)(elem))
	}
	// 返回 value 的地址，直接更新或赋值
	// TODO 此处了已经解除了写标志，是否存在在更新过程中有其他 goroutine 正在读写的问题？
	return elem
}
```
* mapassign 用于向 map 中，与 mapaccess 类似，但是如果 map 中没有该 key 时，会为其分配一个槽
* map 为 nil，直接 panic，无法向一个 nil 中写数据；
* 如果有其他 goroutine 正在写，抛出并发写错误；否则，添加一个写标志，此处对 flags 字段的读写都是非原子非加锁的，所以 map 并不保证并发安全；
* 如果该 map 没有桶，则创建一个新的桶，初始状态为一个桶，与前面 makemap 呼应，makemap 时可以不实际创建桶，只要在需要写入的时候才创建；
* 根据哈希值计算该 key 对应的存储桶数组的索引，假设为 ni，如果该 map 正在扩容，且旧桶数组中应该要迁移到新桶 ni 的旧桶 oi 还没有迁移，则将该旧桶 oi 及其溢出桶进行迁移，再进行遍历；
* 根据 ni 获取桶指针，依次遍历该存储桶及其溢出桶，遍历每个桶时，依次与每个顶部哈希值比较，顶部哈希值相等时，再去与 key 进行比较，key 相等时，获取其对应的 elem 地址并返回，会直接根据该地址对 elem 进行更新或赋值；
* 如果存储桶及其溢出桶都遍历完还没有找到时，则需要向该 map 插入该 key，如果 map 没有在扩容，则需要判断插入 key 后是否会导致 map 触发扩容；
* 如果触发了扩容，则开始扩容，此扩容只创建存储桶数组和溢出桶数组，并分别切换旧存储桶数组指针和旧溢出桶数组指针的指向，不做实际搬迁；
* 开始扩容后，存储桶数组地址发生改变，数组长度可能也会发生改变，需要重新计算桶的索引和地址，以及进行数据迁移，并重新查找，如果仍然找不到，需要将 key 插入 map，能够保证 key 会写入正确的桶；
* 如果 key 找到了，返回其对应的 elem 地址返回；否则，插入 key，并获取其对应的 elem 地址返回；
```go
// 开始扩容，只创建存储桶数组和溢出桶数组，并分别切换旧桶数组指针和旧溢出桶数组指针的指向，不做实际搬迁
func hashGrow(t *maptype, h *hmap) {
	// 如果命中了负载的因子，则翻倍扩容，否则就是有太多的溢出桶，做等量扩容
	bigger := uint8(1)
	if !overLoadFactor(h.count+1, h.B) {
		// 没有超过负载因子，等量扩容
		bigger = 0
		h.flags |= sameSizeGrow
	}
	oldbuckets := h.buckets
	// 创建新存储桶数组和下一个溢出桶
	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)

	// 清除桶的迭代器的状态
	flags := h.flags &^ (iterator | oldIterator)
	if h.flags&iterator != 0 {
		flags |= oldIterator
	}
	h.B += bigger             // 更新桶数量
	h.flags = flags           // 更新标志，如果是 iterator 则更新为 oldIterator
	h.oldbuckets = oldbuckets // 旧桶数组指针指向的是当前存储桶数组
	h.buckets = newbuckets    // 当前存储桶数组指针指向的是新创建的存储数组
	h.nevacuate = 0           // 迁移进度数置为 0
	h.noverflow = 0           // 溢出桶数量置为 0

	if h.extra != nil && h.extra.overflow != nil {
		// 旧溢出桶数组指针不为空，说明上一次扩容可能还没有完成，抛出错误
		if h.extra.oldoverflow != nil {
			throw("oldoverflow is not nil")
		}
		// 将旧溢出桶数组指针指向当前溢出桶数组，并将当前溢出桶数组指针置为 nil
		h.extra.oldoverflow = h.extra.overflow
		h.extra.overflow = nil
	}
	if nextOverflow != nil {
		if h.extra == nil {
			h.extra = new(mapextra)
		}
		// 为下一个溢出桶指针赋值
		h.extra.nextOverflow = nextOverflow
	}

	// 哈希表数据的实际搬迁在 growWork() 和 evacuate() 中
}
```

> **参考文章**<br>
> [1] [二郎腿的博客](https://erlangtui.top)<br>
