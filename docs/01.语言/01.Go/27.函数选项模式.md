---
title: 函数选项模式
date: 2024-04-01 16:42:24
permalink: /pages/5a5425/
categories:
  - 语言
  - Go
tags:
  - 
author: 
  name: erlangtui
  link: https://github.com/erlangtui
---

## 一、基本介绍
- 对于C++语言，如果某个函数需要新增参数，可以通过函数重载或是添加可选参数的方式实现，该函数以前的调用方不需要重新更改，如下：

```cpp
#include <iostream>
#include <string>

void printMessage(const std::string& message) {
    std::cout << message << std::endl;
}

// 函数重载
void printMessage(const std::string& message, int number) {
    std::cout << message << "The number is: " << number << std::endl;
}

// 原先函数
// void greet(const std::string& name)

// 可选参数的函数
void greet(const std::string& name, const std::string& greeting = "Hello") {
    std::cout << greeting << ", " << name << "!" << std::endl;
}

int main() {
    // 调用函数重载
    printMessage("Hello, world!"); // 此调用方不用更改
    printMessage("Hello, world!", 42);

    // 调用带有可选参数的函数
    greet("Alice"); // 此调用方不用更改
    greet("Bob", "Hi");

    return 0;
}
```

- 但是 <span style="color: red;">**go 语言没有函数重载，也不支持可选参数，所以对于某个函数，需要新增不同个数不同类型的参数时，如果直接修改的话，那么该函数以前的所有调用方都需要更改**</span>；
- go 语言支持可变数量的参数，但是该参数的类型必须一致，可以将自定义的函数类型作为参数类型，每个函数参数都是一个闭包，可以读取并处理其外部不同类型的变量，并将其赋值给函数的选项，以此实现某个函数可以接收不同数量不同类型的参数，且需要扩展参数时不用更改函数签名以及调用方，即函数式选项模式；

## 二、基本原理
* 先声明一个`options`结构体，用于存储函数的参数；
* 再声明一个函数指针 Option，该函数的参数是`options`类型的指针，该函数的功能一般是接收其外部的参数并校验，存储到`options`类型的指针中；
* 构造需要传递参数的函数，这些函数可以接受不同类型的参数，**并返回一个 Option 类型的闭包**，在该闭包中处理该参数，每次需要新增参数时，构建一个`func WithXXX(XXX any) Option`函数即可，XXX 为任意类型；
* `func InitOptions(opts ...Option) error`是真正需要接收参数的函数，<span style="color: red;">**它可以接收任意个 Option 类型的函数指针，这样将本应该接收任意个不同类型参数的函数转换为接收任意个 Option 类型参数的函数，即使扩展参数该函数的签名不变，不需要更改其调用方**</span>；
* 只需要在该函数中依次调用 Option 类型的函数，并向其传递`options`结构体指针用于接收 WithXXX 的参数；

::: details
```go
package main

import (
	"errors"
	"fmt"
)

type options struct {
	name    string
	age     int
	dealFun func() error
}

// 表示更新配置结构体的函数类型
type Option func(*options) error

// 该函数返回一个闭包，引用其外部的变量，并进行校验，变量的类型是可变的
func WithName(name string) Option {
	return func(opts *options) error {
		if name == "" {
			return errors.New("name is null")
		}
		opts.name = name
		return nil
	}
}

func WithAge(age int) Option {
	return func(opts *options) error {
		if age < 0 {
			return errors.New("age less than 0")
		}
		opts.age = age
		return nil
	}
}

func WithDealFun(f func() error) Option {
	return func(opts *options) error {
		if f == nil {
			return errors.New("f is nil")
		}
		opts.dealFun = f
		return nil
	}
}

// 通过传递函数列表，每个函数都是一个闭包，函数列表长度是可变的
func InitOptions(opts ...Option) error {
	// 初始化选项
	op := options{}

	// 应用选项
	for _, opt := range opts {
		if err := opt(&op); err != nil {
			// 参数错误能够及时返回
			return err
		}
	}
	return nil
}

func f() error {
	// do something
	return nil
}

func main() {
	// 在需要增加参数的地方构建 WithXXX 函数，并添加到参数列表中，其他调用的地方不需要更改
	err := InitOptions(WithName("go"), WithAge(18), WithDealFun(f))
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println("succeed init")
}
```
:::

## 三、与其他方式的比较
