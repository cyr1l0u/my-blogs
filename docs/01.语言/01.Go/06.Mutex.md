---
title: Mutex
date: 2023-10-29 22:14:25
permalink: /pages/a54c7d/
categories:
  - 语言
  - Go
tags:
  - 
author: 
  name: erlangtui
  link: https://github.com/erlangtui
---

## 一、简述
* Mutex 是一种相对原始的同步机制，只有基础的同步功能，更高级别的同步最好通过 Channel 来实现；
* 锁的对象被创建后，不允许复制；
* 解锁一个未加锁的对象，会出现错误；

## 二、基本原理
* Mutex 可以处于 2 种操作模式：正常和饥饿。
* 在正常模式下：
  * 等待的 goroutine 按照先进先出的顺序排队，但是被唤醒的 goroutine 不会立即拥有互斥锁，而是与新到来的 goroutine 竞争锁的所有权；
  * 因为新到来的 goroutine 有一个优势，它们已经在CPU上运行，并且可能有很多个，所以被唤醒的 goroutine 有可能失败，新到来的 goroutine 拿到锁后继续运行，能够避免上下文的切换；
  * 在这种情况下，被唤醒的 goroutine 会在等待队列的前面排队，如果等的 goroutine 超过 1 毫秒未能获取互斥锁，则会将互斥锁切换到饥饿模式；
* 在饥饿模式下：
  * 互斥锁的所有权直接从解锁的 goroutine 移交给队列前面等待的 goroutine；
  * 新到来的 goroutine 不会尝试获取互斥锁，也不会自旋，它们将自己排在等待队列的尾部；
  * 如果获得锁的 goroutine 是等待队列中的最后一个，或是等待时间少于 1 ms，则会将互斥锁切换回正常模式；
* 正常模式具有更好的性能，因为即使有其他阻塞的 goroutine 等待，当前 goroutine 也可以连续多次获取互斥锁；
* 饥饿模式对于预防尾部延迟具有很好的作用，能够避免等待的 goroutine 饿死；

## 三、基本用法
```go
var m sync.Mutex
m.Lock()
// ... do something
m.UnLock()
```
## 四、源码解读
### 1，Mutex
```go
type Mutex struct {
	state int32  // 锁的状态，32 位，WaiterShift(29位)|Starving|Woken|Locked
	sema  uint32 // 控制锁状态的信号量
}
const (
	mutexLocked           = 1 << iota // 1，互斥锁被锁定状态，位于 state 二进制位最右侧
	mutexWoken                        // 2，互斥锁被唤醒状态
	mutexStarving                     // 4，互斥锁处于饥饿模式
	mutexWaiterShift      = iota      // 3，互斥锁上等待的 goroutine 数量
	starvationThresholdNs = 1e6       // 进入饥饿模式等待的阈值，1e6纳秒，即1ms
)
```
* **Mutex 是互斥锁，其零值是未锁的状态，首次使用后不能被复制**；
* `mutexLocked, mutexWoken, mutexStarving` 分别是

### 2，Lock()
:::detail
```go
// Lock 如果锁已经被使用了，则调用程序一直阻塞直到锁可用
func (m *Mutex) Lock() {
	// 锁当前状态是未锁定的（值为 0 ），并且正好能够将 mutexLocked 位置为1，加锁成功，直接返回
	if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
		if race.Enabled {
			race.Acquire(unsafe.Pointer(m))
		}
		return
	}
	// 当锁不是未锁定的状态时，慢速路径（概述以便可以内联快速路径）
	m.lockSlow()
}

func (m *Mutex) lockSlow() {
	var waitStartTime int64 // 等待时间
	starving := false       // 是否饥饿，即等待时间是否超过 1 ms
	awoke := false          // 是否有协程处于唤醒状态
	iter := 0               // 自旋次数，不能超过四次
	old := m.state          // 锁的当前状态
	for {                   // 开始进行阻塞调用
		// 不要在饥饿模式下自旋，所有权会交给队列前面的等待者协程，所以无论如何都无法获得互斥锁
		// 如果是 mutexLocked 位为 1 且 mutexStarving 位为 0，锁定状态且不是处于饥饿模式，并且符合自旋条件，则开始自旋
		if old&(mutexLocked|mutexStarving) == mutexLocked && runtime_canSpin(iter) {
			// 在自旋等待期间，当前 goroutine 会不断判断是否可以设置 mutexWoken 标志位来通知 Unlock() 方法不必唤醒其他阻塞的 goroutine，避免不必要的唤醒和上下文切换。
			// 如果可以设置，就将 awoke 标识为 true，然后调用 runtime_doSpin() 进行自旋，逐渐增加 iter 计数器，更新 old Mutex 的状态。
			if !awoke && old&mutexWoken == 0 && old>>mutexWaiterShift != 0 &&
				atomic.CompareAndSwapInt32(&m.state, old, old|mutexWoken) {
				// 没有协程被唤醒、锁也不是唤醒状态、还有协程等待的协程，且当前协程能够将锁的状态更新为 mutexWoken
				awoke = true
			}
			runtime_doSpin() // 开始自旋，每次自旋执行 30 次 pause 指令
			iter++           // 自旋计数，次数达到 4 次时，不会再自旋
			old = m.state    // 重新读取互斥锁的状态 m.state，为了在下一次循环中重新检查互斥锁的状态，并决定是否继续自旋
			continue
		}
		// 以下非自旋状态，新到的 goroutine 不要试图获取饥饿模式下的互斥锁，必须排队
		new := old // 创建变量 new，用于存储新的Mutex状态
		if old&mutexStarving == 0 {
			// 互斥锁非饥饿模式，则将 new mutexLocked 置为 1，否则不做处理，等待其他等待者获取 Mutex
			new |= mutexLocked
		}
		if old&(mutexLocked|mutexStarving) != 0 {
			// 互斥锁饥饿模式或已经是加锁状态，则将 new 的 mutexWaiterShift 位置为 1（表示当前goroutine也成为Mutex的等待者）
			new += 1 << mutexWaiterShift
		}

		// 如果当前 Mutex 处于饥饿模式，并且已经有其他 goroutine 持有该 Mutex，则切换到饥饿模式。
		// 如果Mutex未被持有，则不切换到饥饿模式，因为Unlock期望饥饿模式下有等待者，但实际情况不一定有。
		if starving && old&mutexLocked != 0 {
			new |= mutexStarving
		}
		if awoke {
			// goroutine 已从睡眠状态唤醒，因此无论哪种情况，都需要重置标志。
			if new&mutexWoken == 0 {
				// 互斥锁状态不一致，抛出一个错误
				throw("sync: inconsistent mutex state")
			}
			new &^= mutexWoken // 位清除操作，取反后逻辑与
		}
		if atomic.CompareAndSwapInt32(&m.state, old, new) {
			if old&(mutexLocked|mutexStarving) == 0 {
				break // 通过 CAS 方式已经加锁成功
			}
			// 如果已经处于等待的过程中，直接排在队列最前面
			queueLifo := waitStartTime != 0
			if waitStartTime == 0 {
				// 如果没有等待则记录开始等待时刻
				waitStartTime = runtime_nanotime()
			}
			// 通过信号量保证锁只能被 1 个 goroutine 获取到
			runtime_SemacquireMutex(&m.sema, queueLifo, 1)
			// 如果等待时间超过了阈值，那么就进入饥饿模式
			starving = starving || runtime_nanotime()-waitStartTime > starvationThresholdNs
			old = m.state
			if old&mutexStarving != 0 {
				// 如果当前 goroutine 被唤醒并且锁处于饥饿模式
				// 控制权转交给了当前 goroutine，但是互斥锁处于某种不一致的状态：mutexLocked 标识未设置，仍然认为当前 goroutine 正在等待锁
				// 抛出一个错误: mutex 状态不一致
				if old&(mutexLocked|mutexWoken) != 0 || old>>mutexWaiterShift == 0 {
					throw("sync: inconsistent mutex state")
				}
				// 减少等待的 goroutine 数量 (注意偏移量使用方法)
				delta := int32(mutexLocked - 1<<mutexWaiterShift)
				if !starving || old>>mutexWaiterShift == 1 {
					// 等待时间不大于 1 ms，或是最后一个等待者，则退出饥饿模式
					// 必须要在这里退出并且考虑等待时间
					// 饥饿模式效率很低，一旦 2 个 goroutine 同时将互斥锁切换到饥饿模式，可能会陷入无限循环
					delta -= mutexStarving
				}
				atomic.AddInt32(&m.state, delta)
				break
			}
			awoke = true
			iter = 0
		} else {
			old = m.state // 获取锁失败，更新 old 的值，继续进行循环等待
		}
	}

	if race.Enabled {
		race.Acquire(unsafe.Pointer(m))
	}
}

```
:::
### 3, UnLock()
:::detail
```go

```
:::
### 4, Locker
```go

```
