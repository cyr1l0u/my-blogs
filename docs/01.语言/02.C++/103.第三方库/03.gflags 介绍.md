---
title: gflags 介绍
date: 2023-08-03 21:12:49
permalink: /pages/d12608/
categories:
  - 语言
  - C++
  - 第三方库
tags:
  - gflags
author: 
  name: erlangtui
  link: https://github.com/zhangliang6666
---

## 一、基本介绍
* gflag 是 google 开源的**处理命令行参数**的库，用 C++ 编写的，同时提供了 Python 接口；
* 其参数定义**可以分散在各个文件中**，而不是局限于某一个文件，复用性较强；
* 相比于 getopt 应用起来更加灵活与方便，常用于各种开源库中；
* [github地址](https://github.com/gflags/gflags)
* [官方文档](https://gflags.github.io/gflags/)

## 二、安装与编译
### 1，安装二进制包
* 在 `Debian/Ubuntu Linux` 上，可以使用 `apt-get` 命令安装：
```sh
sudo apt-get install libgflags-dev
```
* 在 `CentOS Linux` 上，可以使用 `yum` 命令安装：
```sh
sudo yum install libgflags-dev
```
* 在 `macOS` 上，使用 `Homebrew` 安装：
```sh
brew install gflags
```

### 2，cmake 编译源文件
* `gflags` 的编译要求 CMake 的版本不低于 3.0.2；
* 可以从 `github` 仓库克隆源文件或是直接下载源文件压缩包；

```sh
git clone https://github.com/gflags/gflags
cd gflags
git checkout v2.2.2 (optional)
mkdir build
cd build
cmake ..
make
make test    (optional)
make install (optional)
```

## 三、使用方法
### 1，支持类型
类型|描述
---|---
DEFINE_bool | 布尔
DEFINE_int32 | 32 位整数
DEFINE_int64 | 64 位整数
DEFINE_uint64 | 无符号 64 位整数
DEFINE_double | 双精度浮点数
DEFINE_string | C++字符串

### 2，定义方式
* 在某个文件中键入以下代码定义某些标志；
```cpp
// 文件名为：com_flags.cpp
#include <gflags/gflags.h>

// 标志定义
DEFINE_bool(big_menu, true, "Include 'advanced' options in the menu listing");
DEFINE_string(languages, "english,french,german", "comma-separated list of languages to offer in the 'lang' menu");
```
* 所有 DEFINE 宏都采用相同的三个参数：标志的名称、其默认值和用法描述；
* 可以在可执行文件中的任何源代码文件中定义标志，并在其他文件中声明它后就可以在该文件使用；

### 3，访问方式
* 所有定义的标志，在程序中都可以想变量一样使用它；
* 对应的变量名为：`FLAGS_` 后加上定义的标志名；
* 如上面的定义的标志名对应的变量名为：`FLAGS_big_menu, FLAGS_languages`；
* **a) 同文件访问**
  * 同文件直接通过变量名访问；
  ```cpp
  // 文件名为：com_flags.cpp

  if (FLAGS_big_menu)
      FLAGS_languages += "gflags";
  if (FLAGS_languages.find("flag") != string::npos)
      HandleFinnish();
  ```
* **b) 跨文件访问**
  * 当需要在其他文件中使用该标志时，需要**先声明再访问**；
  * 声明的方式就是将定义标志的 `DEFINE` 换成 `DECLARE`，相当于 C++ 的关键字 `extern`；
  * 以上述例子为基础，在 `main.cc` 文件中访问 `com_flags.cpp` 文件中定义标志；
  * 需要先在 `com_flags.cpp` 的头文件 `com_flags.h` 中进行声明，然后在 `main.cc` 文件中包含该头文件既可： 
    ```cpp
    // 文件名：com_flags.h
    
    // 标志的声明
    DECLARE_bool(big_menu);
    DECLARE_string(languages;
    ```
    ```cpp
    // 文件名：main.cc
    include "com_flags.h"

    if (FLAGS_big_menu)
      FLAGS_languages += "gflags";
    if (FLAGS_languages.find("flag") != string::npos)
      HandleFinnish();
    ```
  * 当变量的定义是在命名空间内定义时，**声明的时候也需要带上命名空间**；
    ```cpp
    // brpc 中的consul服务的标志定义
    namespace brpc {
    namespace policy {

    DEFINE_string(consul_agent_addr, "http://127.0.0.1:8500",
                  "The query string of request consul for discovering service.");
    DEFINE_string(consul_service_discovery_url,
                  "/v1/health/service/",
                  "The url of consul for discovering service.");
    }
    }
    ```
    ```cpp
    // 文件名：main.cc
    
    // 在其他文件中声明标志时带上命名空间
    namespace brpc {
    namespace policy {

    DECLARE_string(consul_agent_addr,);
    DECLARE_string(consul_service_discovery_url);
    // ......
    }
    }
    ```

### 4，注册标志验证器
* 为了校验参数是否符合**自定义的要求**，可以为定义标志注册一个验证器函数；
* 每当该标志**解析或修改**时，都会调用验证器函数 使用新值作为参数；
* 验证器函数应该返回一个布尔值，如果标志值有效，则返回 `true`，否则返回 `false`；
* 如果函数返回 `false`，则标志将保留其当前值;
* 确保注册函数发生在命令行解析的开头；
```cpp
static bool ValidatePort(const char* flagname, int32 value) {
   if (value > 0 && value < 32768)   // value is ok
     return true;
   printf("Invalid value for --%s: %d\n", flagname, (int)value);
   return false;
}
DEFINE_int32(port, 0, "What port to listen on");
static const bool port_dummy = RegisterFlagValidator(&FLAGS_port, &ValidatePort);
```
* 如果注册成功，注册函数返回值为ture。否则返回false，注册失败一般是一下两种原因：
    - 第一个参数不引用命令行标志；
    - 已经为此标志注册了不同的验证器；


<!-- 
组合在一起：如何设置标志
最后一块是告诉可执行文件处理 命令行标志，并将变量设置为 适当的非默认值，基于在 命令行。这相当于调用 getopt 库，但使用的开销要少得多。事实上，它是 只需一次函数调用：FLAGS_*getopt()

   gflags::ParseCommandLineFlags(&argc, &argv, true);
通常，此代码位于 的开头。 并且与传入 的完全一样。此例程可能会修改它们，这就是为什么 指向它们的指针被传入。main()argcargvmain()

最后一个参数称为“remove_flags”。如果为 true，则删除标志及其 来自 的参数，并适当修改。在这种情况下，在函数调用之后，将仅保存命令行参数，而不是 命令行标志。ParseCommandLineFlagsargvargcargv

另一方面，如果为假，则将保持 argc 不变，但将 重新排列 argv 中的参数，以便标志都位于 开始。例如，如果输入是（这是合法的，但很奇怪），则该函数将重新排列，使其读取 .在本例中，将索引返回到包含第一个命令行参数的 argv 中： 也就是说，超过最后一个标志的索引。（在此示例中，它将 返回 2，因为指向 .）remove_flagsParseCommandLineFlags"/bin/foo" "arg1" "-q" "arg2"argv"/bin/foo", "-q", "arg1", "arg2"ParseCommandLineFlagsargv[2]arg1

无论哪种情况，都会修改变量 根据传入的内容 命令行。FLAGS_*

在命令行上设置标志
你把某些东西变成一个标志而不是编译时的原因 常量，以便用户可以在 命令行。以下是他们如何为应用程序执行此操作 链接 ：foo.cc

   app_containing_foo --nobig_menu -languages="chinese,japanese,korean" ...
这将设置和 ，何时运行。FLAGS_big_menu = false;FLAGS_languages = "chinese,japanese,korean"ParseCommandLineFlags

请注意将布尔标志设置为 false 的非典型语法： 在其名称前面加上“否”。有相当多的灵活性 如何指定标志。以下是所有方法的示例 指定“语言”标志：

app_containing_foo --languages="chinese,japanese,korean"
app_containing_foo -languages="chinese,japanese,korean"
app_containing_foo --languages "chinese,japanese,korean"
app_containing_foo -languages "chinese,japanese,korean"
对于布尔标志，可能性略有不同：

app_containing_foo --big_menu
app_containing_foo --nobig_menu
app_containing_foo --big_menu=true
app_containing_foo --big_menu=false
（以及所有这些上的单破折号变体）。

尽管有这种灵活性，我们建议仅使用一种形式：用于非布尔标志和布尔标志。这 一致性将使你的代码更具可读性，这也是格式 对于某些特殊用例（如标志文件）是必需的。--variable=value--variable/--novariable

在命令行上指定具有以下特征的标志是一个致命错误 未在可执行文件中的某处定义。如果你需要那个 出于某种原因的功能 - 假设您想使用同一组 多个可执行文件的标志，但并非所有可执行文件都定义了每个标志 在您的列表中 -- 您可以指定 --undefok 来禁止显示错误。

与getopt（）一样，它本身将终止标志 加工。所以在 中，是 被认为是一面旗帜，但不是。--foo -f1 1 -- -f2 2f1-f2

如果多次指定一个标志，则仅指定最后一个规范 被使用;其他的将被忽略。

请注意，标志没有单字母同义词，就像它们在 getopt 库，我们也不允许在 单破折号，如 中所示。ls -la

更改默认标志值
有时在库中定义了一个标志，并且您想要更改 其默认值在一个应用程序中，而不是其他应用程序中。很简单 这样做：只需为 中的标志分配一个新值，即可 致电前 ：main()ParseCommandLineFlags()

   DECLARE_bool(lib_verbose);   // mylib has a lib_verbose flag, default is false
   int main(int argc, char** argv) {
     FLAGS_lib_verbose = true;  // in my app, I want a verbose lib by default
     ParseCommandLineFlags(...);
   }
对于此应用程序，用户仍然可以在 命令行，但如果没有，标志的值将默认为 真。

特殊标志
命令行标志模块定义了几个标志 本身，并且可用于所有使用 命令行标志。这些属于 三类。首先是“报告”标志，一旦发现，会导致 应用程序打印有关自身的一些信息并退出。

--help	显示所有文件的所有标志，按文件排序，然后按名称排序; 显示标志名称、其默认值及其帮助字符串
--helpfull	与 -help 相同，但明确要求所有标志 （以防将来帮助发生变化）
--helpshort	仅显示与可执行文件同名的文件的标志 （通常是包含main())
--helpxml	像 --help 一样，但输出是 XML 格式的，以便于解析
--helpon=FILE  	仅显示文件中定义的标志。
--helpmatch=S	仅显示 *S* 中定义的标志。
--helppackage	显示与 相同目录中的文件中定义的标志main()
--version	打印可执行文件的版本信息
其次是影响其他标志解析方式的标志。

--undefok=flagname,flagname,...	对于列为参数的名称， 禁止在命令行上看到时发生的正常错误退出，但尚未在 应用--undefok--namename
第三个是“递归”标志，它会导致其他标志值 设置：。这些将在下面进行更多描述 细节。--fromenv--tryfromenv--flagfile

--fromenv
--fromenv=foo,bar说从环境中读取 和 标志的值。 与此标志一致，您必须实际在 环境，通过如下所示的两行之一：foobar

   export FLAGS_foo=xxx; export FLAGS_bar=yyy   # sh
   setenv FLAGS_foo xxx; setenv FLAGS_bar yyy   # tcsh
这等效于在命令行上指定 。--foo=xxx--bar=yyy

请注意，说是否未在应用程序中的某处定义是一个致命错误。（虽然 您可以通过 抑制此错误，就像 一样 对于任何其他标志。--fromenv=foofoo--undefok=foo

说是否实际上没有在环境中定义也是一个致命的错误。--fromenv=fooFLAGS_foo

--tryfromenv
--tryfromenv就像， 除非说如果不是致命错误 实际在环境中定义。相反，在这种情况下，只需保留其默认值，如 应用程序。--fromenv--tryfromenv=fooFLAGS_fooFLAGS_foo

请注意，说是否未在应用程序中的某处定义仍然是一个错误。--tryfromenv=foofoo

--flagfile
--flagfile=f告诉命令行标志模块读取 文件，并运行在 中找到的所有标志赋值 该文件，就好像这些标志是在命令行上指定的一样。f

在最简单的形式中，应该只是一个标志列表 作业，每行一个。与命令行不同，等号 需要将标志名称与其参数分开 标志文件。一个示例标志文件：f/tmp/myflags

--nobig_menus
--languages=english,french
使用此标志文件，以下两行是等效的：

   ./myapp --foo --nobig_menus --languages=english,french --bar
   ./myapp --foo --flagfile=/tmp/myflags --bar
请注意，许多错误在标志文件中以静默方式禁止显示。在 特别是，无法识别的标志名称将被静默忽略，标志也是如此 缺少所需的值（例如，仅显示 ） 的标志文件。--languages

标志文件的一般格式比 简单，上面常见的情况。它是：一系列文件名，每个一个 行，后跟一系列标志，每行一个，重复尽可能多的标志 次如愿以偿。标志文件中的文件名可以使用通配符 （ 和 ），以及位于的标志序列 在处理一系列文件名后，仅当当前 可执行文件的名称与其中一个文件名匹配。有可能 使用一系列标志而不是一系列标志开始标志文件 文件名;如果存在这样的标志序列，则这些标志是 应用于当前可执行文件，无论它是什么。*?

以 开头的行将作为注释被忽略。 标志文件中的前导空格也会被忽略，空白也是如此 线。#

一个标志文件可以使用该标志来包含另一个标志文件。--flagfile

标志始终按预期顺序处理。那是 处理首先检查直接在 命令行。如果指定了标志文件，则处理其内容， 然后继续处理命令中的剩余标志 线。

接口
除了直接访问外，它还 可以通过 API 以编程方式访问标志。是的 还可以访问有关标志的信息，例如其默认值 值和帮助字符串。A 使它变得容易 修改标志，然后稍后自动撤消修改。 最后，有一些不相关但有用的例程可以轻松实现 访问外部主电源的部分，包括程序 名称 （）。FLAGS_fooFlagSaverargvargv[0]

有关这些例程和其他有用帮助程序的详细信息 和等方法，请参见。gflags::SetUsageMessage()gflags::SetVersionStringgflags.h

杂项说明
如果您的应用程序具有如下代码：

   #define STRIP_FLAG_HELP 1    // this must go before the #include!
   #include <gflags/gflags.h>
我们将从编译的源代码中删除帮助消息。这可以 稍微减小生成的二进制文件的大小，也可能 出于安全原因很有用。

问题和功能请求
请在 GitHub 上报告有关其他功能的任何问题或想法。 我们还鼓励对错误修复和新功能实现的拉取请求。

-->